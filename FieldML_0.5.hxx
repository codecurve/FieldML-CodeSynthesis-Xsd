// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef FIELD_ML_0_5_HXX
#define FIELD_ML_0_5_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class FieldmlRdfTargetType;
class FieldmlObject_Type;
class ArrayDataSize_Type;
class ArrayDataOffset_Type;
class RawArraySize_Type;
class ArrayDataSource_Type;
class DataResourceHref_Type;
class DataResourceString_Type;
class DataResourceDescription_Type;
class DataResource_Type;
class ImportTypeEntry_Type;
class ImportEvaluatorEntry_Type;
class Import_Type;
class NumberedIndexEvaluator_Type;
class NumberedIndexEvaluatorList_Type;
class BindMapEntry_Type;
class BindMapIndexEntry_Type;
class BindMapWithIndexes_Type;
class BindMap_Type;
class ComponentEvaluatorsEntry_Type;
class ComponentEvaluators_Type;
class ShapeMap_Type;
class ArgumentListEntry_Type;
class ArgumentList_Type;
class EvaluatorListEntry_Type;
class IndexEvaluatorList_Type;
class OrderedEvaluatorListEntry_Type;
class OrderedIndexEvaluatorList_Type;
class MemberRange_Type;
class MemberData_Type;
class EnsembleMembers_Type;
class BooleanType_Type;
class EnsembleType_Type;
class ContinuousComponent_Type;
class ContinuousType_Type;
class MeshType_Type;
class FieldmlEvaluator_Type;
class ArgumentEvaluator_Type;
class ExternalEvaluator_Type;
class ConstantEvaluator_Type;
class ReferenceEvaluator_Type;
class EvaluatorMapEntry_Type;
class EvaluatorMap_Type;
class PiecewiseEvaluator_Type;
class DenseArrayData_Type;
class DOKArrayData_Type;
class ParameterEvaluator_Type;
class AggregateEvaluator_Type;
class Region_Type;
class Fieldml_Type;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "xlink-href.hxx"

class FieldmlRdfTargetType: public ::xml_schema::type
{
  public:
  // id
  //
  typedef ::xml_schema::string id_type;
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  const id_optional&
  id () const;

  id_optional&
  id ();

  void
  id (const id_type& x);

  void
  id (const id_optional& x);

  void
  id (::std::unique_ptr< id_type > p);

  // Constructors.
  //
  FieldmlRdfTargetType ();

  FieldmlRdfTargetType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  FieldmlRdfTargetType (const FieldmlRdfTargetType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual FieldmlRdfTargetType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FieldmlRdfTargetType&
  operator= (const FieldmlRdfTargetType& x);

  virtual 
  ~FieldmlRdfTargetType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
};

class FieldmlObject_Type: public ::FieldmlRdfTargetType
{
  public:
  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // Constructors.
  //
  FieldmlObject_Type (const name_type&);

  FieldmlObject_Type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  FieldmlObject_Type (const FieldmlObject_Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual FieldmlObject_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FieldmlObject_Type&
  operator= (const FieldmlObject_Type& x);

  virtual 
  ~FieldmlObject_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< name_type > name_;
};

class ArrayDataSize_Type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  ArrayDataSize_Type ();

  ArrayDataSize_Type (const char*);

  ArrayDataSize_Type (const ::std::string&);

  ArrayDataSize_Type (const ::xml_schema::string&);

  ArrayDataSize_Type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ArrayDataSize_Type (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ArrayDataSize_Type (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  ArrayDataSize_Type (const ArrayDataSize_Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual ArrayDataSize_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ArrayDataSize_Type ();
};

class ArrayDataOffset_Type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  ArrayDataOffset_Type ();

  ArrayDataOffset_Type (const char*);

  ArrayDataOffset_Type (const ::std::string&);

  ArrayDataOffset_Type (const ::xml_schema::string&);

  ArrayDataOffset_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ArrayDataOffset_Type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ArrayDataOffset_Type (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ArrayDataOffset_Type (const ArrayDataOffset_Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual ArrayDataOffset_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ArrayDataOffset_Type ();
};

class RawArraySize_Type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  RawArraySize_Type ();

  RawArraySize_Type (const char*);

  RawArraySize_Type (const ::std::string&);

  RawArraySize_Type (const ::xml_schema::string&);

  RawArraySize_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  RawArraySize_Type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  RawArraySize_Type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  RawArraySize_Type (const RawArraySize_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual RawArraySize_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RawArraySize_Type ();
};

class ArrayDataSource_Type: public ::xml_schema::type
{
  public:
  // ArrayDataSize
  //
  typedef ::ArrayDataSize_Type ArrayDataSize_type;
  typedef ::xsd::cxx::tree::sequence< ArrayDataSize_type > ArrayDataSize_sequence;
  typedef ArrayDataSize_sequence::iterator ArrayDataSize_iterator;
  typedef ArrayDataSize_sequence::const_iterator ArrayDataSize_const_iterator;
  typedef ::xsd::cxx::tree::traits< ArrayDataSize_type, char > ArrayDataSize_traits;

  const ArrayDataSize_sequence&
  ArrayDataSize () const;

  ArrayDataSize_sequence&
  ArrayDataSize ();

  void
  ArrayDataSize (const ArrayDataSize_sequence& s);

  // ArrayDataOffset
  //
  typedef ::ArrayDataOffset_Type ArrayDataOffset_type;
  typedef ::xsd::cxx::tree::sequence< ArrayDataOffset_type > ArrayDataOffset_sequence;
  typedef ArrayDataOffset_sequence::iterator ArrayDataOffset_iterator;
  typedef ArrayDataOffset_sequence::const_iterator ArrayDataOffset_const_iterator;
  typedef ::xsd::cxx::tree::traits< ArrayDataOffset_type, char > ArrayDataOffset_traits;

  const ArrayDataOffset_sequence&
  ArrayDataOffset () const;

  ArrayDataOffset_sequence&
  ArrayDataOffset ();

  void
  ArrayDataOffset (const ArrayDataOffset_sequence& s);

  // RawArraySize
  //
  typedef ::RawArraySize_Type RawArraySize_type;
  typedef ::xsd::cxx::tree::sequence< RawArraySize_type > RawArraySize_sequence;
  typedef RawArraySize_sequence::iterator RawArraySize_iterator;
  typedef RawArraySize_sequence::const_iterator RawArraySize_const_iterator;
  typedef ::xsd::cxx::tree::traits< RawArraySize_type, char > RawArraySize_traits;

  const RawArraySize_sequence&
  RawArraySize () const;

  RawArraySize_sequence&
  RawArraySize ();

  void
  RawArraySize (const RawArraySize_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // location
  //
  typedef ::xml_schema::string location_type;
  typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

  const location_type&
  location () const;

  location_type&
  location ();

  void
  location (const location_type& x);

  void
  location (::std::unique_ptr< location_type > p);

  // rank
  //
  typedef ::xml_schema::positive_integer rank_type;
  typedef ::xsd::cxx::tree::traits< rank_type, char > rank_traits;

  const rank_type&
  rank () const;

  rank_type&
  rank ();

  void
  rank (const rank_type& x);

  // Constructors.
  //
  ArrayDataSource_Type (const name_type&,
                        const location_type&,
                        const rank_type&);

  ArrayDataSource_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ArrayDataSource_Type (const ArrayDataSource_Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual ArrayDataSource_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ArrayDataSource_Type&
  operator= (const ArrayDataSource_Type& x);

  virtual 
  ~ArrayDataSource_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ArrayDataSize_sequence ArrayDataSize_;
  ArrayDataOffset_sequence ArrayDataOffset_;
  RawArraySize_sequence RawArraySize_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< location_type > location_;
  ::xsd::cxx::tree::one< rank_type > rank_;
};

class DataResourceHref_Type: public ::xml_schema::type
{
  public:
  // href
  //
  typedef ::xml_schema::uri href_type;
  typedef ::xsd::cxx::tree::traits< href_type, char > href_traits;

  const href_type&
  href () const;

  href_type&
  href ();

  void
  href (const href_type& x);

  void
  href (::std::unique_ptr< href_type > p);

  // format
  //
  typedef ::xml_schema::string format_type;
  typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

  const format_type&
  format () const;

  format_type&
  format ();

  void
  format (const format_type& x);

  void
  format (::std::unique_ptr< format_type > p);

  // Constructors.
  //
  DataResourceHref_Type (const href_type&,
                         const format_type&);

  DataResourceHref_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  DataResourceHref_Type (const DataResourceHref_Type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual DataResourceHref_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DataResourceHref_Type&
  operator= (const DataResourceHref_Type& x);

  virtual 
  ~DataResourceHref_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< href_type > href_;
  ::xsd::cxx::tree::one< format_type > format_;
};

class DataResourceString_Type: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  DataResourceString_Type ();

  DataResourceString_Type (const char*);

  DataResourceString_Type (const ::std::string&);

  DataResourceString_Type (const ::xml_schema::string&);

  DataResourceString_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  DataResourceString_Type (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  DataResourceString_Type (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  DataResourceString_Type (const DataResourceString_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual DataResourceString_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~DataResourceString_Type ();
};

class DataResourceDescription_Type: public ::xml_schema::type
{
  public:
  // DataResourceHref
  //
  typedef ::DataResourceHref_Type DataResourceHref_type;
  typedef ::xsd::cxx::tree::optional< DataResourceHref_type > DataResourceHref_optional;
  typedef ::xsd::cxx::tree::traits< DataResourceHref_type, char > DataResourceHref_traits;

  const DataResourceHref_optional&
  DataResourceHref () const;

  DataResourceHref_optional&
  DataResourceHref ();

  void
  DataResourceHref (const DataResourceHref_type& x);

  void
  DataResourceHref (const DataResourceHref_optional& x);

  void
  DataResourceHref (::std::unique_ptr< DataResourceHref_type > p);

  // DataResourceString
  //
  typedef ::DataResourceString_Type DataResourceString_type;
  typedef ::xsd::cxx::tree::optional< DataResourceString_type > DataResourceString_optional;
  typedef ::xsd::cxx::tree::traits< DataResourceString_type, char > DataResourceString_traits;

  const DataResourceString_optional&
  DataResourceString () const;

  DataResourceString_optional&
  DataResourceString ();

  void
  DataResourceString (const DataResourceString_type& x);

  void
  DataResourceString (const DataResourceString_optional& x);

  void
  DataResourceString (::std::unique_ptr< DataResourceString_type > p);

  // Constructors.
  //
  DataResourceDescription_Type ();

  DataResourceDescription_Type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  DataResourceDescription_Type (const DataResourceDescription_Type& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual DataResourceDescription_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DataResourceDescription_Type&
  operator= (const DataResourceDescription_Type& x);

  virtual 
  ~DataResourceDescription_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DataResourceHref_optional DataResourceHref_;
  DataResourceString_optional DataResourceString_;
};

class DataResource_Type: public ::xml_schema::type
{
  public:
  // DataResourceDescription
  //
  typedef ::DataResourceDescription_Type DataResourceDescription_type;
  typedef ::xsd::cxx::tree::sequence< DataResourceDescription_type > DataResourceDescription_sequence;
  typedef DataResourceDescription_sequence::iterator DataResourceDescription_iterator;
  typedef DataResourceDescription_sequence::const_iterator DataResourceDescription_const_iterator;
  typedef ::xsd::cxx::tree::traits< DataResourceDescription_type, char > DataResourceDescription_traits;

  const DataResourceDescription_sequence&
  DataResourceDescription () const;

  DataResourceDescription_sequence&
  DataResourceDescription ();

  void
  DataResourceDescription (const DataResourceDescription_sequence& s);

  // ArrayDataSource
  //
  typedef ::ArrayDataSource_Type ArrayDataSource_type;
  typedef ::xsd::cxx::tree::sequence< ArrayDataSource_type > ArrayDataSource_sequence;
  typedef ArrayDataSource_sequence::iterator ArrayDataSource_iterator;
  typedef ArrayDataSource_sequence::const_iterator ArrayDataSource_const_iterator;
  typedef ::xsd::cxx::tree::traits< ArrayDataSource_type, char > ArrayDataSource_traits;

  const ArrayDataSource_sequence&
  ArrayDataSource () const;

  ArrayDataSource_sequence&
  ArrayDataSource ();

  void
  ArrayDataSource (const ArrayDataSource_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // Constructors.
  //
  DataResource_Type (const name_type&);

  DataResource_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  DataResource_Type (const DataResource_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual DataResource_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DataResource_Type&
  operator= (const DataResource_Type& x);

  virtual 
  ~DataResource_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DataResourceDescription_sequence DataResourceDescription_;
  ArrayDataSource_sequence ArrayDataSource_;
  ::xsd::cxx::tree::one< name_type > name_;
};

class ImportTypeEntry_Type: public ::xml_schema::type
{
  public:
  // localName
  //
  typedef ::xml_schema::string localName_type;
  typedef ::xsd::cxx::tree::traits< localName_type, char > localName_traits;

  const localName_type&
  localName () const;

  localName_type&
  localName ();

  void
  localName (const localName_type& x);

  void
  localName (::std::unique_ptr< localName_type > p);

  // remoteName
  //
  typedef ::xml_schema::string remoteName_type;
  typedef ::xsd::cxx::tree::traits< remoteName_type, char > remoteName_traits;

  const remoteName_type&
  remoteName () const;

  remoteName_type&
  remoteName ();

  void
  remoteName (const remoteName_type& x);

  void
  remoteName (::std::unique_ptr< remoteName_type > p);

  // Constructors.
  //
  ImportTypeEntry_Type (const localName_type&,
                        const remoteName_type&);

  ImportTypeEntry_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  ImportTypeEntry_Type (const ImportTypeEntry_Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual ImportTypeEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ImportTypeEntry_Type&
  operator= (const ImportTypeEntry_Type& x);

  virtual 
  ~ImportTypeEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< localName_type > localName_;
  ::xsd::cxx::tree::one< remoteName_type > remoteName_;
};

class ImportEvaluatorEntry_Type: public ::xml_schema::type
{
  public:
  // localName
  //
  typedef ::xml_schema::string localName_type;
  typedef ::xsd::cxx::tree::traits< localName_type, char > localName_traits;

  const localName_type&
  localName () const;

  localName_type&
  localName ();

  void
  localName (const localName_type& x);

  void
  localName (::std::unique_ptr< localName_type > p);

  // remoteName
  //
  typedef ::xml_schema::string remoteName_type;
  typedef ::xsd::cxx::tree::traits< remoteName_type, char > remoteName_traits;

  const remoteName_type&
  remoteName () const;

  remoteName_type&
  remoteName ();

  void
  remoteName (const remoteName_type& x);

  void
  remoteName (::std::unique_ptr< remoteName_type > p);

  // Constructors.
  //
  ImportEvaluatorEntry_Type (const localName_type&,
                             const remoteName_type&);

  ImportEvaluatorEntry_Type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  ImportEvaluatorEntry_Type (const ImportEvaluatorEntry_Type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual ImportEvaluatorEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ImportEvaluatorEntry_Type&
  operator= (const ImportEvaluatorEntry_Type& x);

  virtual 
  ~ImportEvaluatorEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< localName_type > localName_;
  ::xsd::cxx::tree::one< remoteName_type > remoteName_;
};

class Import_Type: public ::xml_schema::type
{
  public:
  // ImportType
  //
  typedef ::ImportTypeEntry_Type ImportType_type;
  typedef ::xsd::cxx::tree::sequence< ImportType_type > ImportType_sequence;
  typedef ImportType_sequence::iterator ImportType_iterator;
  typedef ImportType_sequence::const_iterator ImportType_const_iterator;
  typedef ::xsd::cxx::tree::traits< ImportType_type, char > ImportType_traits;

  const ImportType_sequence&
  ImportType () const;

  ImportType_sequence&
  ImportType ();

  void
  ImportType (const ImportType_sequence& s);

  // ImportEvaluator
  //
  typedef ::ImportEvaluatorEntry_Type ImportEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< ImportEvaluator_type > ImportEvaluator_sequence;
  typedef ImportEvaluator_sequence::iterator ImportEvaluator_iterator;
  typedef ImportEvaluator_sequence::const_iterator ImportEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< ImportEvaluator_type, char > ImportEvaluator_traits;

  const ImportEvaluator_sequence&
  ImportEvaluator () const;

  ImportEvaluator_sequence&
  ImportEvaluator ();

  void
  ImportEvaluator (const ImportEvaluator_sequence& s);

  // href
  //
  typedef ::xml_schema::uri href_type;
  typedef ::xsd::cxx::tree::traits< href_type, char > href_traits;

  const href_type&
  href () const;

  href_type&
  href ();

  void
  href (const href_type& x);

  void
  href (::std::unique_ptr< href_type > p);

  // region
  //
  typedef ::xml_schema::string region_type;
  typedef ::xsd::cxx::tree::traits< region_type, char > region_traits;

  const region_type&
  region () const;

  region_type&
  region ();

  void
  region (const region_type& x);

  void
  region (::std::unique_ptr< region_type > p);

  // Constructors.
  //
  Import_Type (const href_type&,
               const region_type&);

  Import_Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  Import_Type (const Import_Type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual Import_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Import_Type&
  operator= (const Import_Type& x);

  virtual 
  ~Import_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ImportType_sequence ImportType_;
  ImportEvaluator_sequence ImportEvaluator_;
  ::xsd::cxx::tree::one< href_type > href_;
  ::xsd::cxx::tree::one< region_type > region_;
};

class NumberedIndexEvaluator_Type: public ::xml_schema::type
{
  public:
  // evaluator
  //
  typedef ::xml_schema::string evaluator_type;
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  const evaluator_type&
  evaluator () const;

  evaluator_type&
  evaluator ();

  void
  evaluator (const evaluator_type& x);

  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  // indexNumber
  //
  typedef ::xml_schema::positive_integer indexNumber_type;
  typedef ::xsd::cxx::tree::traits< indexNumber_type, char > indexNumber_traits;

  const indexNumber_type&
  indexNumber () const;

  indexNumber_type&
  indexNumber ();

  void
  indexNumber (const indexNumber_type& x);

  // Constructors.
  //
  NumberedIndexEvaluator_Type (const evaluator_type&,
                               const indexNumber_type&);

  NumberedIndexEvaluator_Type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  NumberedIndexEvaluator_Type (const NumberedIndexEvaluator_Type& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual NumberedIndexEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  NumberedIndexEvaluator_Type&
  operator= (const NumberedIndexEvaluator_Type& x);

  virtual 
  ~NumberedIndexEvaluator_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
  ::xsd::cxx::tree::one< indexNumber_type > indexNumber_;
};

class NumberedIndexEvaluatorList_Type: public ::xml_schema::type
{
  public:
  // IndexEvaluator
  //
  typedef ::NumberedIndexEvaluator_Type IndexEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< IndexEvaluator_type > IndexEvaluator_sequence;
  typedef IndexEvaluator_sequence::iterator IndexEvaluator_iterator;
  typedef IndexEvaluator_sequence::const_iterator IndexEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< IndexEvaluator_type, char > IndexEvaluator_traits;

  const IndexEvaluator_sequence&
  IndexEvaluator () const;

  IndexEvaluator_sequence&
  IndexEvaluator ();

  void
  IndexEvaluator (const IndexEvaluator_sequence& s);

  // Constructors.
  //
  NumberedIndexEvaluatorList_Type ();

  NumberedIndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  NumberedIndexEvaluatorList_Type (const NumberedIndexEvaluatorList_Type& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual NumberedIndexEvaluatorList_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  NumberedIndexEvaluatorList_Type&
  operator= (const NumberedIndexEvaluatorList_Type& x);

  virtual 
  ~NumberedIndexEvaluatorList_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  IndexEvaluator_sequence IndexEvaluator_;
};

class BindMapEntry_Type: public ::xml_schema::type
{
  public:
  // argument
  //
  typedef ::xml_schema::string argument_type;
  typedef ::xsd::cxx::tree::traits< argument_type, char > argument_traits;

  const argument_type&
  argument () const;

  argument_type&
  argument ();

  void
  argument (const argument_type& x);

  void
  argument (::std::unique_ptr< argument_type > p);

  // source
  //
  typedef ::xml_schema::string source_type;
  typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

  const source_type&
  source () const;

  source_type&
  source ();

  void
  source (const source_type& x);

  void
  source (::std::unique_ptr< source_type > p);

  // Constructors.
  //
  BindMapEntry_Type (const argument_type&,
                     const source_type&);

  BindMapEntry_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  BindMapEntry_Type (const BindMapEntry_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual BindMapEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  BindMapEntry_Type&
  operator= (const BindMapEntry_Type& x);

  virtual 
  ~BindMapEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< argument_type > argument_;
  ::xsd::cxx::tree::one< source_type > source_;
};

class BindMapIndexEntry_Type: public ::xml_schema::type
{
  public:
  // argument
  //
  typedef ::xml_schema::string argument_type;
  typedef ::xsd::cxx::tree::traits< argument_type, char > argument_traits;

  const argument_type&
  argument () const;

  argument_type&
  argument ();

  void
  argument (const argument_type& x);

  void
  argument (::std::unique_ptr< argument_type > p);

  // indexNumber
  //
  typedef ::xml_schema::positive_integer indexNumber_type;
  typedef ::xsd::cxx::tree::traits< indexNumber_type, char > indexNumber_traits;

  const indexNumber_type&
  indexNumber () const;

  indexNumber_type&
  indexNumber ();

  void
  indexNumber (const indexNumber_type& x);

  // Constructors.
  //
  BindMapIndexEntry_Type (const argument_type&,
                          const indexNumber_type&);

  BindMapIndexEntry_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  BindMapIndexEntry_Type (const BindMapIndexEntry_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual BindMapIndexEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  BindMapIndexEntry_Type&
  operator= (const BindMapIndexEntry_Type& x);

  virtual 
  ~BindMapIndexEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< argument_type > argument_;
  ::xsd::cxx::tree::one< indexNumber_type > indexNumber_;
};

class BindMapWithIndexes_Type: public ::xml_schema::type
{
  public:
  // BindIndex
  //
  typedef ::BindMapIndexEntry_Type BindIndex_type;
  typedef ::xsd::cxx::tree::sequence< BindIndex_type > BindIndex_sequence;
  typedef BindIndex_sequence::iterator BindIndex_iterator;
  typedef BindIndex_sequence::const_iterator BindIndex_const_iterator;
  typedef ::xsd::cxx::tree::traits< BindIndex_type, char > BindIndex_traits;

  const BindIndex_sequence&
  BindIndex () const;

  BindIndex_sequence&
  BindIndex ();

  void
  BindIndex (const BindIndex_sequence& s);

  // Bind
  //
  typedef ::BindMapEntry_Type Bind_type;
  typedef ::xsd::cxx::tree::sequence< Bind_type > Bind_sequence;
  typedef Bind_sequence::iterator Bind_iterator;
  typedef Bind_sequence::const_iterator Bind_const_iterator;
  typedef ::xsd::cxx::tree::traits< Bind_type, char > Bind_traits;

  const Bind_sequence&
  Bind () const;

  Bind_sequence&
  Bind ();

  void
  Bind (const Bind_sequence& s);

  // Constructors.
  //
  BindMapWithIndexes_Type ();

  BindMapWithIndexes_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  BindMapWithIndexes_Type (const BindMapWithIndexes_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual BindMapWithIndexes_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  BindMapWithIndexes_Type&
  operator= (const BindMapWithIndexes_Type& x);

  virtual 
  ~BindMapWithIndexes_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  BindIndex_sequence BindIndex_;
  Bind_sequence Bind_;
};

class BindMap_Type: public ::xml_schema::type
{
  public:
  // Bind
  //
  typedef ::BindMapEntry_Type Bind_type;
  typedef ::xsd::cxx::tree::sequence< Bind_type > Bind_sequence;
  typedef Bind_sequence::iterator Bind_iterator;
  typedef Bind_sequence::const_iterator Bind_const_iterator;
  typedef ::xsd::cxx::tree::traits< Bind_type, char > Bind_traits;

  const Bind_sequence&
  Bind () const;

  Bind_sequence&
  Bind ();

  void
  Bind (const Bind_sequence& s);

  // Constructors.
  //
  BindMap_Type ();

  BindMap_Type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  BindMap_Type (const BindMap_Type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual BindMap_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  BindMap_Type&
  operator= (const BindMap_Type& x);

  virtual 
  ~BindMap_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Bind_sequence Bind_;
};

class ComponentEvaluatorsEntry_Type: public ::xml_schema::type
{
  public:
  // component
  //
  typedef ::xml_schema::positive_integer component_type;
  typedef ::xsd::cxx::tree::traits< component_type, char > component_traits;

  const component_type&
  component () const;

  component_type&
  component ();

  void
  component (const component_type& x);

  // evaluator
  //
  typedef ::xml_schema::string evaluator_type;
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  const evaluator_type&
  evaluator () const;

  evaluator_type&
  evaluator ();

  void
  evaluator (const evaluator_type& x);

  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  // Constructors.
  //
  ComponentEvaluatorsEntry_Type (const component_type&,
                                 const evaluator_type&);

  ComponentEvaluatorsEntry_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  ComponentEvaluatorsEntry_Type (const ComponentEvaluatorsEntry_Type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual ComponentEvaluatorsEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ComponentEvaluatorsEntry_Type&
  operator= (const ComponentEvaluatorsEntry_Type& x);

  virtual 
  ~ComponentEvaluatorsEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< component_type > component_;
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
};

class ComponentEvaluators_Type: public ::xml_schema::type
{
  public:
  // ComponentEvaluator
  //
  typedef ::ComponentEvaluatorsEntry_Type ComponentEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< ComponentEvaluator_type > ComponentEvaluator_sequence;
  typedef ComponentEvaluator_sequence::iterator ComponentEvaluator_iterator;
  typedef ComponentEvaluator_sequence::const_iterator ComponentEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< ComponentEvaluator_type, char > ComponentEvaluator_traits;

  const ComponentEvaluator_sequence&
  ComponentEvaluator () const;

  ComponentEvaluator_sequence&
  ComponentEvaluator ();

  void
  ComponentEvaluator (const ComponentEvaluator_sequence& s);

  // default
  //
  typedef ::xml_schema::string default_type;
  typedef ::xsd::cxx::tree::optional< default_type > default_optional;
  typedef ::xsd::cxx::tree::traits< default_type, char > default_traits;

  const default_optional&
  default_ () const;

  default_optional&
  default_ ();

  void
  default_ (const default_type& x);

  void
  default_ (const default_optional& x);

  void
  default_ (::std::unique_ptr< default_type > p);

  // Constructors.
  //
  ComponentEvaluators_Type ();

  ComponentEvaluators_Type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  ComponentEvaluators_Type (const ComponentEvaluators_Type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual ComponentEvaluators_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ComponentEvaluators_Type&
  operator= (const ComponentEvaluators_Type& x);

  virtual 
  ~ComponentEvaluators_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ComponentEvaluator_sequence ComponentEvaluator_;
  default_optional default__;
};

class ShapeMap_Type: public ::xml_schema::type
{
  public:
  // evaluator
  //
  typedef ::xml_schema::string evaluator_type;
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  const evaluator_type&
  evaluator () const;

  evaluator_type&
  evaluator ();

  void
  evaluator (const evaluator_type& x);

  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  // Constructors.
  //
  ShapeMap_Type (const evaluator_type&);

  ShapeMap_Type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  ShapeMap_Type (const ShapeMap_Type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual ShapeMap_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ShapeMap_Type&
  operator= (const ShapeMap_Type& x);

  virtual 
  ~ShapeMap_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
};

class ArgumentListEntry_Type: public ::xml_schema::type
{
  public:
  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // Constructors.
  //
  ArgumentListEntry_Type (const name_type&);

  ArgumentListEntry_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  ArgumentListEntry_Type (const ArgumentListEntry_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual ArgumentListEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ArgumentListEntry_Type&
  operator= (const ArgumentListEntry_Type& x);

  virtual 
  ~ArgumentListEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< name_type > name_;
};

class ArgumentList_Type: public ::xml_schema::type
{
  public:
  // Argument
  //
  typedef ::ArgumentListEntry_Type Argument_type;
  typedef ::xsd::cxx::tree::sequence< Argument_type > Argument_sequence;
  typedef Argument_sequence::iterator Argument_iterator;
  typedef Argument_sequence::const_iterator Argument_const_iterator;
  typedef ::xsd::cxx::tree::traits< Argument_type, char > Argument_traits;

  const Argument_sequence&
  Argument () const;

  Argument_sequence&
  Argument ();

  void
  Argument (const Argument_sequence& s);

  // Constructors.
  //
  ArgumentList_Type ();

  ArgumentList_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ArgumentList_Type (const ArgumentList_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual ArgumentList_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ArgumentList_Type&
  operator= (const ArgumentList_Type& x);

  virtual 
  ~ArgumentList_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Argument_sequence Argument_;
};

class EvaluatorListEntry_Type: public ::xml_schema::type
{
  public:
  // evaluator
  //
  typedef ::xml_schema::string evaluator_type;
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  const evaluator_type&
  evaluator () const;

  evaluator_type&
  evaluator ();

  void
  evaluator (const evaluator_type& x);

  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  // Constructors.
  //
  EvaluatorListEntry_Type (const evaluator_type&);

  EvaluatorListEntry_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  EvaluatorListEntry_Type (const EvaluatorListEntry_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual EvaluatorListEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  EvaluatorListEntry_Type&
  operator= (const EvaluatorListEntry_Type& x);

  virtual 
  ~EvaluatorListEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
};

class IndexEvaluatorList_Type: public ::xml_schema::type
{
  public:
  // IndexEvaluator
  //
  typedef ::EvaluatorListEntry_Type IndexEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< IndexEvaluator_type > IndexEvaluator_sequence;
  typedef IndexEvaluator_sequence::iterator IndexEvaluator_iterator;
  typedef IndexEvaluator_sequence::const_iterator IndexEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< IndexEvaluator_type, char > IndexEvaluator_traits;

  const IndexEvaluator_sequence&
  IndexEvaluator () const;

  IndexEvaluator_sequence&
  IndexEvaluator ();

  void
  IndexEvaluator (const IndexEvaluator_sequence& s);

  // Constructors.
  //
  IndexEvaluatorList_Type ();

  IndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  IndexEvaluatorList_Type (const IndexEvaluatorList_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual IndexEvaluatorList_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  IndexEvaluatorList_Type&
  operator= (const IndexEvaluatorList_Type& x);

  virtual 
  ~IndexEvaluatorList_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  IndexEvaluator_sequence IndexEvaluator_;
};

class OrderedEvaluatorListEntry_Type: public ::xml_schema::type
{
  public:
  // evaluator
  //
  typedef ::xml_schema::string evaluator_type;
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  const evaluator_type&
  evaluator () const;

  evaluator_type&
  evaluator ();

  void
  evaluator (const evaluator_type& x);

  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  // order
  //
  typedef ::xml_schema::string order_type;
  typedef ::xsd::cxx::tree::optional< order_type > order_optional;
  typedef ::xsd::cxx::tree::traits< order_type, char > order_traits;

  const order_optional&
  order () const;

  order_optional&
  order ();

  void
  order (const order_type& x);

  void
  order (const order_optional& x);

  void
  order (::std::unique_ptr< order_type > p);

  // Constructors.
  //
  OrderedEvaluatorListEntry_Type (const evaluator_type&);

  OrderedEvaluatorListEntry_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  OrderedEvaluatorListEntry_Type (const OrderedEvaluatorListEntry_Type& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual OrderedEvaluatorListEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OrderedEvaluatorListEntry_Type&
  operator= (const OrderedEvaluatorListEntry_Type& x);

  virtual 
  ~OrderedEvaluatorListEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
  order_optional order_;
};

class OrderedIndexEvaluatorList_Type: public ::xml_schema::type
{
  public:
  // IndexEvaluator
  //
  typedef ::OrderedEvaluatorListEntry_Type IndexEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< IndexEvaluator_type > IndexEvaluator_sequence;
  typedef IndexEvaluator_sequence::iterator IndexEvaluator_iterator;
  typedef IndexEvaluator_sequence::const_iterator IndexEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< IndexEvaluator_type, char > IndexEvaluator_traits;

  const IndexEvaluator_sequence&
  IndexEvaluator () const;

  IndexEvaluator_sequence&
  IndexEvaluator ();

  void
  IndexEvaluator (const IndexEvaluator_sequence& s);

  // Constructors.
  //
  OrderedIndexEvaluatorList_Type ();

  OrderedIndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  OrderedIndexEvaluatorList_Type (const OrderedIndexEvaluatorList_Type& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual OrderedIndexEvaluatorList_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OrderedIndexEvaluatorList_Type&
  operator= (const OrderedIndexEvaluatorList_Type& x);

  virtual 
  ~OrderedIndexEvaluatorList_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  IndexEvaluator_sequence IndexEvaluator_;
};

class MemberRange_Type: public ::xml_schema::type
{
  public:
  // min
  //
  typedef ::xml_schema::non_negative_integer min_type;
  typedef ::xsd::cxx::tree::traits< min_type, char > min_traits;

  const min_type&
  min () const;

  min_type&
  min ();

  void
  min (const min_type& x);

  // max
  //
  typedef ::xml_schema::non_negative_integer max_type;
  typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

  const max_type&
  max () const;

  max_type&
  max ();

  void
  max (const max_type& x);

  // stride
  //
  typedef ::xml_schema::positive_integer stride_type;
  typedef ::xsd::cxx::tree::optional< stride_type > stride_optional;
  typedef ::xsd::cxx::tree::traits< stride_type, char > stride_traits;

  const stride_optional&
  stride () const;

  stride_optional&
  stride ();

  void
  stride (const stride_type& x);

  void
  stride (const stride_optional& x);

  // Constructors.
  //
  MemberRange_Type (const min_type&,
                    const max_type&);

  MemberRange_Type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  MemberRange_Type (const MemberRange_Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual MemberRange_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MemberRange_Type&
  operator= (const MemberRange_Type& x);

  virtual 
  ~MemberRange_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< min_type > min_;
  ::xsd::cxx::tree::one< max_type > max_;
  stride_optional stride_;
};

class MemberData_Type: public ::xml_schema::type
{
  public:
  // count
  //
  typedef ::xml_schema::positive_integer count_type;
  typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

  const count_type&
  count () const;

  count_type&
  count ();

  void
  count (const count_type& x);

  // data
  //
  typedef ::xml_schema::string data_type;
  typedef ::xsd::cxx::tree::traits< data_type, char > data_traits;

  const data_type&
  data () const;

  data_type&
  data ();

  void
  data (const data_type& x);

  void
  data (::std::unique_ptr< data_type > p);

  // Constructors.
  //
  MemberData_Type (const count_type&,
                   const data_type&);

  MemberData_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  MemberData_Type (const MemberData_Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual MemberData_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MemberData_Type&
  operator= (const MemberData_Type& x);

  virtual 
  ~MemberData_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< count_type > count_;
  ::xsd::cxx::tree::one< data_type > data_;
};

class EnsembleMembers_Type: public ::xml_schema::type
{
  public:
  // MemberListData
  //
  typedef ::MemberData_Type MemberListData_type;
  typedef ::xsd::cxx::tree::optional< MemberListData_type > MemberListData_optional;
  typedef ::xsd::cxx::tree::traits< MemberListData_type, char > MemberListData_traits;

  const MemberListData_optional&
  MemberListData () const;

  MemberListData_optional&
  MemberListData ();

  void
  MemberListData (const MemberListData_type& x);

  void
  MemberListData (const MemberListData_optional& x);

  void
  MemberListData (::std::unique_ptr< MemberListData_type > p);

  // MemberRangeData
  //
  typedef ::MemberData_Type MemberRangeData_type;
  typedef ::xsd::cxx::tree::optional< MemberRangeData_type > MemberRangeData_optional;
  typedef ::xsd::cxx::tree::traits< MemberRangeData_type, char > MemberRangeData_traits;

  const MemberRangeData_optional&
  MemberRangeData () const;

  MemberRangeData_optional&
  MemberRangeData ();

  void
  MemberRangeData (const MemberRangeData_type& x);

  void
  MemberRangeData (const MemberRangeData_optional& x);

  void
  MemberRangeData (::std::unique_ptr< MemberRangeData_type > p);

  // MemberStrideRangeData
  //
  typedef ::MemberData_Type MemberStrideRangeData_type;
  typedef ::xsd::cxx::tree::optional< MemberStrideRangeData_type > MemberStrideRangeData_optional;
  typedef ::xsd::cxx::tree::traits< MemberStrideRangeData_type, char > MemberStrideRangeData_traits;

  const MemberStrideRangeData_optional&
  MemberStrideRangeData () const;

  MemberStrideRangeData_optional&
  MemberStrideRangeData ();

  void
  MemberStrideRangeData (const MemberStrideRangeData_type& x);

  void
  MemberStrideRangeData (const MemberStrideRangeData_optional& x);

  void
  MemberStrideRangeData (::std::unique_ptr< MemberStrideRangeData_type > p);

  // MemberRange
  //
  typedef ::MemberRange_Type MemberRange_type;
  typedef ::xsd::cxx::tree::optional< MemberRange_type > MemberRange_optional;
  typedef ::xsd::cxx::tree::traits< MemberRange_type, char > MemberRange_traits;

  const MemberRange_optional&
  MemberRange () const;

  MemberRange_optional&
  MemberRange ();

  void
  MemberRange (const MemberRange_type& x);

  void
  MemberRange (const MemberRange_optional& x);

  void
  MemberRange (::std::unique_ptr< MemberRange_type > p);

  // Constructors.
  //
  EnsembleMembers_Type ();

  EnsembleMembers_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  EnsembleMembers_Type (const EnsembleMembers_Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual EnsembleMembers_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  EnsembleMembers_Type&
  operator= (const EnsembleMembers_Type& x);

  virtual 
  ~EnsembleMembers_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  MemberListData_optional MemberListData_;
  MemberRangeData_optional MemberRangeData_;
  MemberStrideRangeData_optional MemberStrideRangeData_;
  MemberRange_optional MemberRange_;
};

class BooleanType_Type: public ::FieldmlObject_Type
{
  public:
  // Constructors.
  //
  BooleanType_Type (const name_type&);

  BooleanType_Type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  BooleanType_Type (const BooleanType_Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual BooleanType_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~BooleanType_Type ();
};

class EnsembleType_Type: public ::FieldmlObject_Type
{
  public:
  // Members
  //
  typedef ::EnsembleMembers_Type Members_type;
  typedef ::xsd::cxx::tree::traits< Members_type, char > Members_traits;

  const Members_type&
  Members () const;

  Members_type&
  Members ();

  void
  Members (const Members_type& x);

  void
  Members (::std::unique_ptr< Members_type > p);

  // Constructors.
  //
  EnsembleType_Type (const name_type&,
                     const Members_type&);

  EnsembleType_Type (const name_type&,
                     ::std::unique_ptr< Members_type >);

  EnsembleType_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  EnsembleType_Type (const EnsembleType_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual EnsembleType_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  EnsembleType_Type&
  operator= (const EnsembleType_Type& x);

  virtual 
  ~EnsembleType_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Members_type > Members_;
};

class ContinuousComponent_Type: public ::xml_schema::type
{
  public:
  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // count
  //
  typedef ::xml_schema::positive_integer count_type;
  typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

  const count_type&
  count () const;

  count_type&
  count ();

  void
  count (const count_type& x);

  // Constructors.
  //
  ContinuousComponent_Type (const name_type&,
                            const count_type&);

  ContinuousComponent_Type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  ContinuousComponent_Type (const ContinuousComponent_Type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual ContinuousComponent_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ContinuousComponent_Type&
  operator= (const ContinuousComponent_Type& x);

  virtual 
  ~ContinuousComponent_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< count_type > count_;
};

class ContinuousType_Type: public ::FieldmlObject_Type
{
  public:
  // Components
  //
  typedef ::ContinuousComponent_Type Components_type;
  typedef ::xsd::cxx::tree::optional< Components_type > Components_optional;
  typedef ::xsd::cxx::tree::traits< Components_type, char > Components_traits;

  const Components_optional&
  Components () const;

  Components_optional&
  Components ();

  void
  Components (const Components_type& x);

  void
  Components (const Components_optional& x);

  void
  Components (::std::unique_ptr< Components_type > p);

  // Constructors.
  //
  ContinuousType_Type (const name_type&);

  ContinuousType_Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  ContinuousType_Type (const ContinuousType_Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual ContinuousType_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ContinuousType_Type&
  operator= (const ContinuousType_Type& x);

  virtual 
  ~ContinuousType_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Components_optional Components_;
};

class MeshType_Type: public ::FieldmlObject_Type
{
  public:
  // Elements
  //
  typedef ::EnsembleType_Type Elements_type;
  typedef ::xsd::cxx::tree::traits< Elements_type, char > Elements_traits;

  const Elements_type&
  Elements () const;

  Elements_type&
  Elements ();

  void
  Elements (const Elements_type& x);

  void
  Elements (::std::unique_ptr< Elements_type > p);

  // Chart
  //
  typedef ::ContinuousType_Type Chart_type;
  typedef ::xsd::cxx::tree::traits< Chart_type, char > Chart_traits;

  const Chart_type&
  Chart () const;

  Chart_type&
  Chart ();

  void
  Chart (const Chart_type& x);

  void
  Chart (::std::unique_ptr< Chart_type > p);

  // Shapes
  //
  typedef ::ShapeMap_Type Shapes_type;
  typedef ::xsd::cxx::tree::traits< Shapes_type, char > Shapes_traits;

  const Shapes_type&
  Shapes () const;

  Shapes_type&
  Shapes ();

  void
  Shapes (const Shapes_type& x);

  void
  Shapes (::std::unique_ptr< Shapes_type > p);

  // Constructors.
  //
  MeshType_Type (const name_type&,
                 const Elements_type&,
                 const Chart_type&,
                 const Shapes_type&);

  MeshType_Type (const name_type&,
                 ::std::unique_ptr< Elements_type >,
                 ::std::unique_ptr< Chart_type >,
                 ::std::unique_ptr< Shapes_type >);

  MeshType_Type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  MeshType_Type (const MeshType_Type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual MeshType_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MeshType_Type&
  operator= (const MeshType_Type& x);

  virtual 
  ~MeshType_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Elements_type > Elements_;
  ::xsd::cxx::tree::one< Chart_type > Chart_;
  ::xsd::cxx::tree::one< Shapes_type > Shapes_;
};

class FieldmlEvaluator_Type: public ::FieldmlObject_Type
{
  public:
  // Arguments
  //
  typedef ::ArgumentList_Type Arguments_type;
  typedef ::xsd::cxx::tree::optional< Arguments_type > Arguments_optional;
  typedef ::xsd::cxx::tree::traits< Arguments_type, char > Arguments_traits;

  const Arguments_optional&
  Arguments () const;

  Arguments_optional&
  Arguments ();

  void
  Arguments (const Arguments_type& x);

  void
  Arguments (const Arguments_optional& x);

  void
  Arguments (::std::unique_ptr< Arguments_type > p);

  // valueType
  //
  typedef ::xml_schema::string valueType_type;
  typedef ::xsd::cxx::tree::traits< valueType_type, char > valueType_traits;

  const valueType_type&
  valueType () const;

  valueType_type&
  valueType ();

  void
  valueType (const valueType_type& x);

  void
  valueType (::std::unique_ptr< valueType_type > p);

  // Constructors.
  //
  FieldmlEvaluator_Type (const name_type&,
                         const valueType_type&);

  FieldmlEvaluator_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  FieldmlEvaluator_Type (const FieldmlEvaluator_Type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual FieldmlEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FieldmlEvaluator_Type&
  operator= (const FieldmlEvaluator_Type& x);

  virtual 
  ~FieldmlEvaluator_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Arguments_optional Arguments_;
  ::xsd::cxx::tree::one< valueType_type > valueType_;
};

class ArgumentEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  // Constructors.
  //
  ArgumentEvaluator_Type (const name_type&,
                          const valueType_type&);

  ArgumentEvaluator_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  ArgumentEvaluator_Type (const ArgumentEvaluator_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual ArgumentEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ArgumentEvaluator_Type ();
};

class ExternalEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  // Constructors.
  //
  ExternalEvaluator_Type (const name_type&,
                          const valueType_type&);

  ExternalEvaluator_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  ExternalEvaluator_Type (const ExternalEvaluator_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual ExternalEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ExternalEvaluator_Type ();
};

class ConstantEvaluator_Type: public ::FieldmlObject_Type
{
  public:
  // value
  //
  typedef ::xml_schema::string value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  void
  value (::std::unique_ptr< value_type > p);

  // valueType
  //
  typedef ::xml_schema::string valueType_type;
  typedef ::xsd::cxx::tree::traits< valueType_type, char > valueType_traits;

  const valueType_type&
  valueType () const;

  valueType_type&
  valueType ();

  void
  valueType (const valueType_type& x);

  void
  valueType (::std::unique_ptr< valueType_type > p);

  // Constructors.
  //
  ConstantEvaluator_Type (const name_type&,
                          const value_type&,
                          const valueType_type&);

  ConstantEvaluator_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  ConstantEvaluator_Type (const ConstantEvaluator_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual ConstantEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ConstantEvaluator_Type&
  operator= (const ConstantEvaluator_Type& x);

  virtual 
  ~ConstantEvaluator_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< valueType_type > valueType_;
};

class ReferenceEvaluator_Type: public ::FieldmlObject_Type
{
  public:
  // Arguments
  //
  typedef ::ArgumentList_Type Arguments_type;
  typedef ::xsd::cxx::tree::optional< Arguments_type > Arguments_optional;
  typedef ::xsd::cxx::tree::traits< Arguments_type, char > Arguments_traits;

  const Arguments_optional&
  Arguments () const;

  Arguments_optional&
  Arguments ();

  void
  Arguments (const Arguments_type& x);

  void
  Arguments (const Arguments_optional& x);

  void
  Arguments (::std::unique_ptr< Arguments_type > p);

  // Bindings
  //
  typedef ::BindMap_Type Bindings_type;
  typedef ::xsd::cxx::tree::optional< Bindings_type > Bindings_optional;
  typedef ::xsd::cxx::tree::traits< Bindings_type, char > Bindings_traits;

  const Bindings_optional&
  Bindings () const;

  Bindings_optional&
  Bindings ();

  void
  Bindings (const Bindings_type& x);

  void
  Bindings (const Bindings_optional& x);

  void
  Bindings (::std::unique_ptr< Bindings_type > p);

  // valueType
  //
  typedef ::xml_schema::string valueType_type;
  typedef ::xsd::cxx::tree::optional< valueType_type > valueType_optional;
  typedef ::xsd::cxx::tree::traits< valueType_type, char > valueType_traits;

  const valueType_optional&
  valueType () const;

  valueType_optional&
  valueType ();

  void
  valueType (const valueType_type& x);

  void
  valueType (const valueType_optional& x);

  void
  valueType (::std::unique_ptr< valueType_type > p);

  // evaluator
  //
  typedef ::xml_schema::string evaluator_type;
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  const evaluator_type&
  evaluator () const;

  evaluator_type&
  evaluator ();

  void
  evaluator (const evaluator_type& x);

  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  // Constructors.
  //
  ReferenceEvaluator_Type (const name_type&,
                           const evaluator_type&);

  ReferenceEvaluator_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  ReferenceEvaluator_Type (const ReferenceEvaluator_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual ReferenceEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ReferenceEvaluator_Type&
  operator= (const ReferenceEvaluator_Type& x);

  virtual 
  ~ReferenceEvaluator_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Arguments_optional Arguments_;
  Bindings_optional Bindings_;
  valueType_optional valueType_;
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
};

class EvaluatorMapEntry_Type: public ::xml_schema::type
{
  public:
  // value
  //
  typedef ::xml_schema::non_negative_integer value_type;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_type&
  value () const;

  value_type&
  value ();

  void
  value (const value_type& x);

  // evaluator
  //
  typedef ::xml_schema::string evaluator_type;
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  const evaluator_type&
  evaluator () const;

  evaluator_type&
  evaluator ();

  void
  evaluator (const evaluator_type& x);

  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  // Constructors.
  //
  EvaluatorMapEntry_Type (const value_type&,
                          const evaluator_type&);

  EvaluatorMapEntry_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  EvaluatorMapEntry_Type (const EvaluatorMapEntry_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  virtual EvaluatorMapEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  EvaluatorMapEntry_Type&
  operator= (const EvaluatorMapEntry_Type& x);

  virtual 
  ~EvaluatorMapEntry_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
};

class EvaluatorMap_Type: public ::xml_schema::type
{
  public:
  // EvaluatorMapEntry
  //
  typedef ::EvaluatorMapEntry_Type EvaluatorMapEntry_type;
  typedef ::xsd::cxx::tree::sequence< EvaluatorMapEntry_type > EvaluatorMapEntry_sequence;
  typedef EvaluatorMapEntry_sequence::iterator EvaluatorMapEntry_iterator;
  typedef EvaluatorMapEntry_sequence::const_iterator EvaluatorMapEntry_const_iterator;
  typedef ::xsd::cxx::tree::traits< EvaluatorMapEntry_type, char > EvaluatorMapEntry_traits;

  const EvaluatorMapEntry_sequence&
  EvaluatorMapEntry () const;

  EvaluatorMapEntry_sequence&
  EvaluatorMapEntry ();

  void
  EvaluatorMapEntry (const EvaluatorMapEntry_sequence& s);

  // default
  //
  typedef ::xml_schema::string default_type;
  typedef ::xsd::cxx::tree::optional< default_type > default_optional;
  typedef ::xsd::cxx::tree::traits< default_type, char > default_traits;

  const default_optional&
  default_ () const;

  default_optional&
  default_ ();

  void
  default_ (const default_type& x);

  void
  default_ (const default_optional& x);

  void
  default_ (::std::unique_ptr< default_type > p);

  // Constructors.
  //
  EvaluatorMap_Type ();

  EvaluatorMap_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  EvaluatorMap_Type (const EvaluatorMap_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual EvaluatorMap_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  EvaluatorMap_Type&
  operator= (const EvaluatorMap_Type& x);

  virtual 
  ~EvaluatorMap_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  EvaluatorMapEntry_sequence EvaluatorMapEntry_;
  default_optional default__;
};

class PiecewiseEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  // Bindings
  //
  typedef ::BindMap_Type Bindings_type;
  typedef ::xsd::cxx::tree::optional< Bindings_type > Bindings_optional;
  typedef ::xsd::cxx::tree::traits< Bindings_type, char > Bindings_traits;

  const Bindings_optional&
  Bindings () const;

  Bindings_optional&
  Bindings ();

  void
  Bindings (const Bindings_type& x);

  void
  Bindings (const Bindings_optional& x);

  void
  Bindings (::std::unique_ptr< Bindings_type > p);

  // IndexEvaluators
  //
  typedef ::NumberedIndexEvaluatorList_Type IndexEvaluators_type;
  typedef ::xsd::cxx::tree::optional< IndexEvaluators_type > IndexEvaluators_optional;
  typedef ::xsd::cxx::tree::traits< IndexEvaluators_type, char > IndexEvaluators_traits;

  const IndexEvaluators_optional&
  IndexEvaluators () const;

  IndexEvaluators_optional&
  IndexEvaluators ();

  void
  IndexEvaluators (const IndexEvaluators_type& x);

  void
  IndexEvaluators (const IndexEvaluators_optional& x);

  void
  IndexEvaluators (::std::unique_ptr< IndexEvaluators_type > p);

  // EvaluatorMap
  //
  typedef ::EvaluatorMap_Type EvaluatorMap_type;
  typedef ::xsd::cxx::tree::traits< EvaluatorMap_type, char > EvaluatorMap_traits;

  const EvaluatorMap_type&
  EvaluatorMap () const;

  EvaluatorMap_type&
  EvaluatorMap ();

  void
  EvaluatorMap (const EvaluatorMap_type& x);

  void
  EvaluatorMap (::std::unique_ptr< EvaluatorMap_type > p);

  // Constructors.
  //
  PiecewiseEvaluator_Type (const name_type&,
                           const valueType_type&,
                           const EvaluatorMap_type&);

  PiecewiseEvaluator_Type (const name_type&,
                           const valueType_type&,
                           ::std::unique_ptr< EvaluatorMap_type >);

  PiecewiseEvaluator_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  PiecewiseEvaluator_Type (const PiecewiseEvaluator_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual PiecewiseEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PiecewiseEvaluator_Type&
  operator= (const PiecewiseEvaluator_Type& x);

  virtual 
  ~PiecewiseEvaluator_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Bindings_optional Bindings_;
  IndexEvaluators_optional IndexEvaluators_;
  ::xsd::cxx::tree::one< EvaluatorMap_type > EvaluatorMap_;
};

class DenseArrayData_Type: public ::xml_schema::type
{
  public:
  // DenseIndexes
  //
  typedef ::OrderedIndexEvaluatorList_Type DenseIndexes_type;
  typedef ::xsd::cxx::tree::optional< DenseIndexes_type > DenseIndexes_optional;
  typedef ::xsd::cxx::tree::traits< DenseIndexes_type, char > DenseIndexes_traits;

  const DenseIndexes_optional&
  DenseIndexes () const;

  DenseIndexes_optional&
  DenseIndexes ();

  void
  DenseIndexes (const DenseIndexes_type& x);

  void
  DenseIndexes (const DenseIndexes_optional& x);

  void
  DenseIndexes (::std::unique_ptr< DenseIndexes_type > p);

  // data
  //
  typedef ::xml_schema::string data_type;
  typedef ::xsd::cxx::tree::traits< data_type, char > data_traits;

  const data_type&
  data () const;

  data_type&
  data ();

  void
  data (const data_type& x);

  void
  data (::std::unique_ptr< data_type > p);

  // Constructors.
  //
  DenseArrayData_Type (const data_type&);

  DenseArrayData_Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  DenseArrayData_Type (const DenseArrayData_Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual DenseArrayData_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DenseArrayData_Type&
  operator= (const DenseArrayData_Type& x);

  virtual 
  ~DenseArrayData_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DenseIndexes_optional DenseIndexes_;
  ::xsd::cxx::tree::one< data_type > data_;
};

class DOKArrayData_Type: public ::xml_schema::type
{
  public:
  // DenseIndexes
  //
  typedef ::OrderedIndexEvaluatorList_Type DenseIndexes_type;
  typedef ::xsd::cxx::tree::optional< DenseIndexes_type > DenseIndexes_optional;
  typedef ::xsd::cxx::tree::traits< DenseIndexes_type, char > DenseIndexes_traits;

  const DenseIndexes_optional&
  DenseIndexes () const;

  DenseIndexes_optional&
  DenseIndexes ();

  void
  DenseIndexes (const DenseIndexes_type& x);

  void
  DenseIndexes (const DenseIndexes_optional& x);

  void
  DenseIndexes (::std::unique_ptr< DenseIndexes_type > p);

  // SparseIndexes
  //
  typedef ::IndexEvaluatorList_Type SparseIndexes_type;
  typedef ::xsd::cxx::tree::traits< SparseIndexes_type, char > SparseIndexes_traits;

  const SparseIndexes_type&
  SparseIndexes () const;

  SparseIndexes_type&
  SparseIndexes ();

  void
  SparseIndexes (const SparseIndexes_type& x);

  void
  SparseIndexes (::std::unique_ptr< SparseIndexes_type > p);

  // keyData
  //
  typedef ::xml_schema::string keyData_type;
  typedef ::xsd::cxx::tree::traits< keyData_type, char > keyData_traits;

  const keyData_type&
  keyData () const;

  keyData_type&
  keyData ();

  void
  keyData (const keyData_type& x);

  void
  keyData (::std::unique_ptr< keyData_type > p);

  // valueData
  //
  typedef ::xml_schema::string valueData_type;
  typedef ::xsd::cxx::tree::traits< valueData_type, char > valueData_traits;

  const valueData_type&
  valueData () const;

  valueData_type&
  valueData ();

  void
  valueData (const valueData_type& x);

  void
  valueData (::std::unique_ptr< valueData_type > p);

  // Constructors.
  //
  DOKArrayData_Type (const SparseIndexes_type&,
                     const keyData_type&,
                     const valueData_type&);

  DOKArrayData_Type (::std::unique_ptr< SparseIndexes_type >,
                     const keyData_type&,
                     const valueData_type&);

  DOKArrayData_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  DOKArrayData_Type (const DOKArrayData_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual DOKArrayData_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DOKArrayData_Type&
  operator= (const DOKArrayData_Type& x);

  virtual 
  ~DOKArrayData_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DenseIndexes_optional DenseIndexes_;
  ::xsd::cxx::tree::one< SparseIndexes_type > SparseIndexes_;
  ::xsd::cxx::tree::one< keyData_type > keyData_;
  ::xsd::cxx::tree::one< valueData_type > valueData_;
};

class ParameterEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  // DenseArrayData
  //
  typedef ::DenseArrayData_Type DenseArrayData_type;
  typedef ::xsd::cxx::tree::optional< DenseArrayData_type > DenseArrayData_optional;
  typedef ::xsd::cxx::tree::traits< DenseArrayData_type, char > DenseArrayData_traits;

  const DenseArrayData_optional&
  DenseArrayData () const;

  DenseArrayData_optional&
  DenseArrayData ();

  void
  DenseArrayData (const DenseArrayData_type& x);

  void
  DenseArrayData (const DenseArrayData_optional& x);

  void
  DenseArrayData (::std::unique_ptr< DenseArrayData_type > p);

  // DOKArrayData
  //
  typedef ::DOKArrayData_Type DOKArrayData_type;
  typedef ::xsd::cxx::tree::optional< DOKArrayData_type > DOKArrayData_optional;
  typedef ::xsd::cxx::tree::traits< DOKArrayData_type, char > DOKArrayData_traits;

  const DOKArrayData_optional&
  DOKArrayData () const;

  DOKArrayData_optional&
  DOKArrayData ();

  void
  DOKArrayData (const DOKArrayData_type& x);

  void
  DOKArrayData (const DOKArrayData_optional& x);

  void
  DOKArrayData (::std::unique_ptr< DOKArrayData_type > p);

  // Constructors.
  //
  ParameterEvaluator_Type (const name_type&,
                           const valueType_type&);

  ParameterEvaluator_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  ParameterEvaluator_Type (const ParameterEvaluator_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual ParameterEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ParameterEvaluator_Type&
  operator= (const ParameterEvaluator_Type& x);

  virtual 
  ~ParameterEvaluator_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DenseArrayData_optional DenseArrayData_;
  DOKArrayData_optional DOKArrayData_;
};

class AggregateEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  // Bindings
  //
  typedef ::BindMapWithIndexes_Type Bindings_type;
  typedef ::xsd::cxx::tree::optional< Bindings_type > Bindings_optional;
  typedef ::xsd::cxx::tree::traits< Bindings_type, char > Bindings_traits;

  const Bindings_optional&
  Bindings () const;

  Bindings_optional&
  Bindings ();

  void
  Bindings (const Bindings_type& x);

  void
  Bindings (const Bindings_optional& x);

  void
  Bindings (::std::unique_ptr< Bindings_type > p);

  // ComponentEvaluators
  //
  typedef ::ComponentEvaluators_Type ComponentEvaluators_type;
  typedef ::xsd::cxx::tree::traits< ComponentEvaluators_type, char > ComponentEvaluators_traits;

  const ComponentEvaluators_type&
  ComponentEvaluators () const;

  ComponentEvaluators_type&
  ComponentEvaluators ();

  void
  ComponentEvaluators (const ComponentEvaluators_type& x);

  void
  ComponentEvaluators (::std::unique_ptr< ComponentEvaluators_type > p);

  // Constructors.
  //
  AggregateEvaluator_Type (const name_type&,
                           const valueType_type&,
                           const ComponentEvaluators_type&);

  AggregateEvaluator_Type (const name_type&,
                           const valueType_type&,
                           ::std::unique_ptr< ComponentEvaluators_type >);

  AggregateEvaluator_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  AggregateEvaluator_Type (const AggregateEvaluator_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual AggregateEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  AggregateEvaluator_Type&
  operator= (const AggregateEvaluator_Type& x);

  virtual 
  ~AggregateEvaluator_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Bindings_optional Bindings_;
  ::xsd::cxx::tree::one< ComponentEvaluators_type > ComponentEvaluators_;
};

class Region_Type: public ::FieldmlRdfTargetType
{
  public:
  // Import
  //
  typedef ::Import_Type Import_type;
  typedef ::xsd::cxx::tree::sequence< Import_type > Import_sequence;
  typedef Import_sequence::iterator Import_iterator;
  typedef Import_sequence::const_iterator Import_const_iterator;
  typedef ::xsd::cxx::tree::traits< Import_type, char > Import_traits;

  const Import_sequence&
  Import () const;

  Import_sequence&
  Import ();

  void
  Import (const Import_sequence& s);

  // DataResource
  //
  typedef ::DataResource_Type DataResource_type;
  typedef ::xsd::cxx::tree::sequence< DataResource_type > DataResource_sequence;
  typedef DataResource_sequence::iterator DataResource_iterator;
  typedef DataResource_sequence::const_iterator DataResource_const_iterator;
  typedef ::xsd::cxx::tree::traits< DataResource_type, char > DataResource_traits;

  const DataResource_sequence&
  DataResource () const;

  DataResource_sequence&
  DataResource ();

  void
  DataResource (const DataResource_sequence& s);

  // BooleanType
  //
  typedef ::BooleanType_Type BooleanType_type;
  typedef ::xsd::cxx::tree::sequence< BooleanType_type > BooleanType_sequence;
  typedef BooleanType_sequence::iterator BooleanType_iterator;
  typedef BooleanType_sequence::const_iterator BooleanType_const_iterator;
  typedef ::xsd::cxx::tree::traits< BooleanType_type, char > BooleanType_traits;

  const BooleanType_sequence&
  BooleanType () const;

  BooleanType_sequence&
  BooleanType ();

  void
  BooleanType (const BooleanType_sequence& s);

  // EnsembleType
  //
  typedef ::EnsembleType_Type EnsembleType_type;
  typedef ::xsd::cxx::tree::sequence< EnsembleType_type > EnsembleType_sequence;
  typedef EnsembleType_sequence::iterator EnsembleType_iterator;
  typedef EnsembleType_sequence::const_iterator EnsembleType_const_iterator;
  typedef ::xsd::cxx::tree::traits< EnsembleType_type, char > EnsembleType_traits;

  const EnsembleType_sequence&
  EnsembleType () const;

  EnsembleType_sequence&
  EnsembleType ();

  void
  EnsembleType (const EnsembleType_sequence& s);

  // ContinuousType
  //
  typedef ::ContinuousType_Type ContinuousType_type;
  typedef ::xsd::cxx::tree::sequence< ContinuousType_type > ContinuousType_sequence;
  typedef ContinuousType_sequence::iterator ContinuousType_iterator;
  typedef ContinuousType_sequence::const_iterator ContinuousType_const_iterator;
  typedef ::xsd::cxx::tree::traits< ContinuousType_type, char > ContinuousType_traits;

  const ContinuousType_sequence&
  ContinuousType () const;

  ContinuousType_sequence&
  ContinuousType ();

  void
  ContinuousType (const ContinuousType_sequence& s);

  // MeshType
  //
  typedef ::MeshType_Type MeshType_type;
  typedef ::xsd::cxx::tree::sequence< MeshType_type > MeshType_sequence;
  typedef MeshType_sequence::iterator MeshType_iterator;
  typedef MeshType_sequence::const_iterator MeshType_const_iterator;
  typedef ::xsd::cxx::tree::traits< MeshType_type, char > MeshType_traits;

  const MeshType_sequence&
  MeshType () const;

  MeshType_sequence&
  MeshType ();

  void
  MeshType (const MeshType_sequence& s);

  // ArgumentEvaluator
  //
  typedef ::ArgumentEvaluator_Type ArgumentEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< ArgumentEvaluator_type > ArgumentEvaluator_sequence;
  typedef ArgumentEvaluator_sequence::iterator ArgumentEvaluator_iterator;
  typedef ArgumentEvaluator_sequence::const_iterator ArgumentEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< ArgumentEvaluator_type, char > ArgumentEvaluator_traits;

  const ArgumentEvaluator_sequence&
  ArgumentEvaluator () const;

  ArgumentEvaluator_sequence&
  ArgumentEvaluator ();

  void
  ArgumentEvaluator (const ArgumentEvaluator_sequence& s);

  // ExternalEvaluator
  //
  typedef ::ExternalEvaluator_Type ExternalEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< ExternalEvaluator_type > ExternalEvaluator_sequence;
  typedef ExternalEvaluator_sequence::iterator ExternalEvaluator_iterator;
  typedef ExternalEvaluator_sequence::const_iterator ExternalEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< ExternalEvaluator_type, char > ExternalEvaluator_traits;

  const ExternalEvaluator_sequence&
  ExternalEvaluator () const;

  ExternalEvaluator_sequence&
  ExternalEvaluator ();

  void
  ExternalEvaluator (const ExternalEvaluator_sequence& s);

  // ReferenceEvaluator
  //
  typedef ::ReferenceEvaluator_Type ReferenceEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< ReferenceEvaluator_type > ReferenceEvaluator_sequence;
  typedef ReferenceEvaluator_sequence::iterator ReferenceEvaluator_iterator;
  typedef ReferenceEvaluator_sequence::const_iterator ReferenceEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< ReferenceEvaluator_type, char > ReferenceEvaluator_traits;

  const ReferenceEvaluator_sequence&
  ReferenceEvaluator () const;

  ReferenceEvaluator_sequence&
  ReferenceEvaluator ();

  void
  ReferenceEvaluator (const ReferenceEvaluator_sequence& s);

  // ConstantEvaluator
  //
  typedef ::ConstantEvaluator_Type ConstantEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< ConstantEvaluator_type > ConstantEvaluator_sequence;
  typedef ConstantEvaluator_sequence::iterator ConstantEvaluator_iterator;
  typedef ConstantEvaluator_sequence::const_iterator ConstantEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< ConstantEvaluator_type, char > ConstantEvaluator_traits;

  const ConstantEvaluator_sequence&
  ConstantEvaluator () const;

  ConstantEvaluator_sequence&
  ConstantEvaluator ();

  void
  ConstantEvaluator (const ConstantEvaluator_sequence& s);

  // PiecewiseEvaluator
  //
  typedef ::PiecewiseEvaluator_Type PiecewiseEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< PiecewiseEvaluator_type > PiecewiseEvaluator_sequence;
  typedef PiecewiseEvaluator_sequence::iterator PiecewiseEvaluator_iterator;
  typedef PiecewiseEvaluator_sequence::const_iterator PiecewiseEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< PiecewiseEvaluator_type, char > PiecewiseEvaluator_traits;

  const PiecewiseEvaluator_sequence&
  PiecewiseEvaluator () const;

  PiecewiseEvaluator_sequence&
  PiecewiseEvaluator ();

  void
  PiecewiseEvaluator (const PiecewiseEvaluator_sequence& s);

  // ParameterEvaluator
  //
  typedef ::ParameterEvaluator_Type ParameterEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< ParameterEvaluator_type > ParameterEvaluator_sequence;
  typedef ParameterEvaluator_sequence::iterator ParameterEvaluator_iterator;
  typedef ParameterEvaluator_sequence::const_iterator ParameterEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< ParameterEvaluator_type, char > ParameterEvaluator_traits;

  const ParameterEvaluator_sequence&
  ParameterEvaluator () const;

  ParameterEvaluator_sequence&
  ParameterEvaluator ();

  void
  ParameterEvaluator (const ParameterEvaluator_sequence& s);

  // AggregateEvaluator
  //
  typedef ::AggregateEvaluator_Type AggregateEvaluator_type;
  typedef ::xsd::cxx::tree::sequence< AggregateEvaluator_type > AggregateEvaluator_sequence;
  typedef AggregateEvaluator_sequence::iterator AggregateEvaluator_iterator;
  typedef AggregateEvaluator_sequence::const_iterator AggregateEvaluator_const_iterator;
  typedef ::xsd::cxx::tree::traits< AggregateEvaluator_type, char > AggregateEvaluator_traits;

  const AggregateEvaluator_sequence&
  AggregateEvaluator () const;

  AggregateEvaluator_sequence&
  AggregateEvaluator ();

  void
  AggregateEvaluator (const AggregateEvaluator_sequence& s);

  // name
  //
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::unique_ptr< name_type > p);

  // Constructors.
  //
  Region_Type (const name_type&);

  Region_Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  Region_Type (const Region_Type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual Region_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Region_Type&
  operator= (const Region_Type& x);

  virtual 
  ~Region_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Import_sequence Import_;
  DataResource_sequence DataResource_;
  BooleanType_sequence BooleanType_;
  EnsembleType_sequence EnsembleType_;
  ContinuousType_sequence ContinuousType_;
  MeshType_sequence MeshType_;
  ArgumentEvaluator_sequence ArgumentEvaluator_;
  ExternalEvaluator_sequence ExternalEvaluator_;
  ReferenceEvaluator_sequence ReferenceEvaluator_;
  ConstantEvaluator_sequence ConstantEvaluator_;
  PiecewiseEvaluator_sequence PiecewiseEvaluator_;
  ParameterEvaluator_sequence ParameterEvaluator_;
  AggregateEvaluator_sequence AggregateEvaluator_;
  ::xsd::cxx::tree::one< name_type > name_;
};

class Fieldml_Type: public ::FieldmlRdfTargetType
{
  public:
  // Region
  //
  typedef ::Region_Type Region_type;
  typedef ::xsd::cxx::tree::traits< Region_type, char > Region_traits;

  const Region_type&
  Region () const;

  Region_type&
  Region ();

  void
  Region (const Region_type& x);

  void
  Region (::std::unique_ptr< Region_type > p);

  // version
  //
  typedef ::xml_schema::string version_type;
  typedef ::xsd::cxx::tree::optional< version_type > version_optional;
  typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

  const version_optional&
  version () const;

  version_optional&
  version ();

  void
  version (const version_type& x);

  void
  version (const version_optional& x);

  void
  version (::std::unique_ptr< version_type > p);

  // Constructors.
  //
  Fieldml_Type (const Region_type&);

  Fieldml_Type (::std::unique_ptr< Region_type >);

  Fieldml_Type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  Fieldml_Type (const Fieldml_Type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual Fieldml_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Fieldml_Type&
  operator= (const Fieldml_Type& x);

  virtual 
  ~Fieldml_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Region_type > Region_;
  version_optional version_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& uri,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& uri,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& uri,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& id,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // FIELD_ML_0_5_HXX
