// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from FieldML_0.5.xsd.
 */

#ifndef FIELD_ML_0_5_HXX
#define FIELD_ML_0_5_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class FieldmlRdfTargetType;
class FieldmlObject_Type;
class ArrayDataSize_Type;
class ArrayDataOffset_Type;
class RawArraySize_Type;
class ArrayDataSource_Type;
class DataResourceHref_Type;
class DataResourceString_Type;
class DataResourceDescription_Type;
class DataResource_Type;
class ImportTypeEntry_Type;
class ImportEvaluatorEntry_Type;
class Import_Type;
class NumberedIndexEvaluator_Type;
class NumberedIndexEvaluatorList_Type;
class BindMapEntry_Type;
class BindMapIndexEntry_Type;
class BindMapWithIndexes_Type;
class BindMap_Type;
class ComponentEvaluatorsEntry_Type;
class ComponentEvaluators_Type;
class ShapeMap_Type;
class ArgumentListEntry_Type;
class ArgumentList_Type;
class EvaluatorListEntry_Type;
class IndexEvaluatorList_Type;
class OrderedEvaluatorListEntry_Type;
class OrderedIndexEvaluatorList_Type;
class MemberRange_Type;
class MemberData_Type;
class EnsembleMembers_Type;
class BooleanType_Type;
class EnsembleType_Type;
class ContinuousComponent_Type;
class ContinuousType_Type;
class MeshType_Type;
class FieldmlEvaluator_Type;
class ArgumentEvaluator_Type;
class ExternalEvaluator_Type;
class ConstantEvaluator_Type;
class ReferenceEvaluator_Type;
class EvaluatorMapEntry_Type;
class EvaluatorMap_Type;
class PiecewiseEvaluator_Type;
class DenseArrayData_Type;
class DOKArrayData_Type;
class ParameterEvaluator_Type;
class AggregateEvaluator_Type;
class Region_Type;
class Fieldml_Type;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "xlink-href.hxx"

/**
 * @brief Class corresponding to the %FieldmlRdfTargetType schema type.
 *
 * @nosubgrouping
 */
class FieldmlRdfTargetType: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string id_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const id_optional&
  id () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  id_optional&
  id ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  id (const id_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  id (const id_optional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  id (::std::unique_ptr< id_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FieldmlRdfTargetType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FieldmlRdfTargetType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FieldmlRdfTargetType (const FieldmlRdfTargetType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FieldmlRdfTargetType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FieldmlRdfTargetType&
  operator= (const FieldmlRdfTargetType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FieldmlRdfTargetType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FieldmlObject_Type schema type.
 *
 * @nosubgrouping
 */
class FieldmlObject_Type: public ::FieldmlRdfTargetType
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const name_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< name_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FieldmlObject_Type (const name_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FieldmlObject_Type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FieldmlObject_Type (const FieldmlObject_Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FieldmlObject_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FieldmlObject_Type&
  operator= (const FieldmlObject_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FieldmlObject_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< name_type > name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ArrayDataSize_Type schema type.
 *
 * @nosubgrouping
 */
class ArrayDataSize_Type: public ::xml_schema::string
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required 
   * elements and attributes.
   */
  ArrayDataSize_Type ();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  ArrayDataSize_Type (const char*);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  ArrayDataSize_Type (const ::std::string&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ArrayDataSize_Type (const ::xml_schema::string&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArrayDataSize_Type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArrayDataSize_Type (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArrayDataSize_Type (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArrayDataSize_Type (const ArrayDataSize_Type& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ArrayDataSize_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ArrayDataSize_Type ();
};

/**
 * @brief Class corresponding to the %ArrayDataOffset_Type schema type.
 *
 * @nosubgrouping
 */
class ArrayDataOffset_Type: public ::xml_schema::string
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required 
   * elements and attributes.
   */
  ArrayDataOffset_Type ();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  ArrayDataOffset_Type (const char*);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  ArrayDataOffset_Type (const ::std::string&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ArrayDataOffset_Type (const ::xml_schema::string&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArrayDataOffset_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArrayDataOffset_Type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArrayDataOffset_Type (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArrayDataOffset_Type (const ArrayDataOffset_Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ArrayDataOffset_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ArrayDataOffset_Type ();
};

/**
 * @brief Class corresponding to the %RawArraySize_Type schema type.
 *
 * @nosubgrouping
 */
class RawArraySize_Type: public ::xml_schema::string
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required 
   * elements and attributes.
   */
  RawArraySize_Type ();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  RawArraySize_Type (const char*);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  RawArraySize_Type (const ::std::string&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  RawArraySize_Type (const ::xml_schema::string&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  RawArraySize_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  RawArraySize_Type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  RawArraySize_Type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  RawArraySize_Type (const RawArraySize_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual RawArraySize_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~RawArraySize_Type ();
};

/**
 * @brief Class corresponding to the %ArrayDataSource_Type schema type.
 *
 * @nosubgrouping
 */
class ArrayDataSource_Type: public ::xml_schema::type
{
  public:
  /**
   * @name ArrayDataSize
   *
   * @brief Accessor and modifier functions for the %ArrayDataSize
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ArrayDataSize_Type ArrayDataSize_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ArrayDataSize_type > ArrayDataSize_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ArrayDataSize_sequence::iterator ArrayDataSize_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ArrayDataSize_sequence::const_iterator ArrayDataSize_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ArrayDataSize_type, char > ArrayDataSize_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ArrayDataSize_sequence&
  ArrayDataSize () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ArrayDataSize_sequence&
  ArrayDataSize ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ArrayDataSize (const ArrayDataSize_sequence& s);

  //@}

  /**
   * @name ArrayDataOffset
   *
   * @brief Accessor and modifier functions for the %ArrayDataOffset
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ArrayDataOffset_Type ArrayDataOffset_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ArrayDataOffset_type > ArrayDataOffset_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ArrayDataOffset_sequence::iterator ArrayDataOffset_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ArrayDataOffset_sequence::const_iterator ArrayDataOffset_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ArrayDataOffset_type, char > ArrayDataOffset_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ArrayDataOffset_sequence&
  ArrayDataOffset () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ArrayDataOffset_sequence&
  ArrayDataOffset ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ArrayDataOffset (const ArrayDataOffset_sequence& s);

  //@}

  /**
   * @name RawArraySize
   *
   * @brief Accessor and modifier functions for the %RawArraySize
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::RawArraySize_Type RawArraySize_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< RawArraySize_type > RawArraySize_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef RawArraySize_sequence::iterator RawArraySize_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef RawArraySize_sequence::const_iterator RawArraySize_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< RawArraySize_type, char > RawArraySize_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const RawArraySize_sequence&
  RawArraySize () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  RawArraySize_sequence&
  RawArraySize ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  RawArraySize (const RawArraySize_sequence& s);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const name_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< name_type > p);

  //@}

  /**
   * @name location
   *
   * @brief Accessor and modifier functions for the %location
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string location_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< location_type, char > location_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const location_type&
  location () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  location_type&
  location ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  location (const location_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  location (::std::unique_ptr< location_type > p);

  //@}

  /**
   * @name rank
   *
   * @brief Accessor and modifier functions for the %rank
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer rank_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< rank_type, char > rank_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const rank_type&
  rank () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  rank_type&
  rank ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  rank (const rank_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ArrayDataSource_Type (const name_type&,
                        const location_type&,
                        const rank_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArrayDataSource_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArrayDataSource_Type (const ArrayDataSource_Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ArrayDataSource_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArrayDataSource_Type&
  operator= (const ArrayDataSource_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ArrayDataSource_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ArrayDataSize_sequence ArrayDataSize_;
  ArrayDataOffset_sequence ArrayDataOffset_;
  RawArraySize_sequence RawArraySize_;
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< location_type > location_;
  ::xsd::cxx::tree::one< rank_type > rank_;

  //@endcond
};

/**
 * @brief Class corresponding to the %DataResourceHref_Type schema type.
 *
 * @nosubgrouping
 */
class DataResourceHref_Type: public ::xml_schema::type
{
  public:
  /**
   * @name href
   *
   * @brief Accessor and modifier functions for the %href
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::uri href_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< href_type, char > href_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const href_type&
  href () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  href_type&
  href ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  href (const href_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  href (::std::unique_ptr< href_type > p);

  //@}

  /**
   * @name format
   *
   * @brief Accessor and modifier functions for the %format
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string format_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< format_type, char > format_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const format_type&
  format () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  format_type&
  format ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  format (const format_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  format (::std::unique_ptr< format_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DataResourceHref_Type (const href_type&,
                         const format_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DataResourceHref_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DataResourceHref_Type (const DataResourceHref_Type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DataResourceHref_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DataResourceHref_Type&
  operator= (const DataResourceHref_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DataResourceHref_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< href_type > href_;
  ::xsd::cxx::tree::one< format_type > format_;

  //@endcond
};

/**
 * @brief Class corresponding to the %DataResourceString_Type schema type.
 *
 * @nosubgrouping
 */
class DataResourceString_Type: public ::xml_schema::string
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from initializers for required 
   * elements and attributes.
   */
  DataResourceString_Type ();

  /**
   * @brief Create an instance from a C string and initializers
   * for required elements and attributes.
   */
  DataResourceString_Type (const char*);

  /**
   * @brief Create an instance from a string andinitializers
   * for required elements and attributes.
   */
  DataResourceString_Type (const ::std::string&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DataResourceString_Type (const ::xml_schema::string&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DataResourceString_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DataResourceString_Type (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DataResourceString_Type (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DataResourceString_Type (const DataResourceString_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DataResourceString_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DataResourceString_Type ();
};

/**
 * @brief Class corresponding to the %DataResourceDescription_Type schema type.
 *
 * @nosubgrouping
 */
class DataResourceDescription_Type: public ::xml_schema::type
{
  public:
  /**
   * @name DataResourceHref
   *
   * @brief Accessor and modifier functions for the %DataResourceHref
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DataResourceHref_Type DataResourceHref_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DataResourceHref_type > DataResourceHref_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DataResourceHref_type, char > DataResourceHref_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DataResourceHref_optional&
  DataResourceHref () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  DataResourceHref_optional&
  DataResourceHref ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DataResourceHref (const DataResourceHref_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  DataResourceHref (const DataResourceHref_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DataResourceHref (::std::unique_ptr< DataResourceHref_type > p);

  //@}

  /**
   * @name DataResourceString
   *
   * @brief Accessor and modifier functions for the %DataResourceString
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DataResourceString_Type DataResourceString_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DataResourceString_type > DataResourceString_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DataResourceString_type, char > DataResourceString_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DataResourceString_optional&
  DataResourceString () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  DataResourceString_optional&
  DataResourceString ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DataResourceString (const DataResourceString_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  DataResourceString (const DataResourceString_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DataResourceString (::std::unique_ptr< DataResourceString_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DataResourceDescription_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DataResourceDescription_Type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DataResourceDescription_Type (const DataResourceDescription_Type& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DataResourceDescription_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DataResourceDescription_Type&
  operator= (const DataResourceDescription_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DataResourceDescription_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DataResourceHref_optional DataResourceHref_;
  DataResourceString_optional DataResourceString_;

  //@endcond
};

/**
 * @brief Class corresponding to the %DataResource_Type schema type.
 *
 * @nosubgrouping
 */
class DataResource_Type: public ::xml_schema::type
{
  public:
  /**
   * @name DataResourceDescription
   *
   * @brief Accessor and modifier functions for the %DataResourceDescription
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DataResourceDescription_Type DataResourceDescription_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< DataResourceDescription_type > DataResourceDescription_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef DataResourceDescription_sequence::iterator DataResourceDescription_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef DataResourceDescription_sequence::const_iterator DataResourceDescription_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DataResourceDescription_type, char > DataResourceDescription_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const DataResourceDescription_sequence&
  DataResourceDescription () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  DataResourceDescription_sequence&
  DataResourceDescription ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  DataResourceDescription (const DataResourceDescription_sequence& s);

  //@}

  /**
   * @name ArrayDataSource
   *
   * @brief Accessor and modifier functions for the %ArrayDataSource
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ArrayDataSource_Type ArrayDataSource_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ArrayDataSource_type > ArrayDataSource_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ArrayDataSource_sequence::iterator ArrayDataSource_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ArrayDataSource_sequence::const_iterator ArrayDataSource_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ArrayDataSource_type, char > ArrayDataSource_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ArrayDataSource_sequence&
  ArrayDataSource () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ArrayDataSource_sequence&
  ArrayDataSource ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ArrayDataSource (const ArrayDataSource_sequence& s);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const name_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< name_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DataResource_Type (const name_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DataResource_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DataResource_Type (const DataResource_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DataResource_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DataResource_Type&
  operator= (const DataResource_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DataResource_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DataResourceDescription_sequence DataResourceDescription_;
  ArrayDataSource_sequence ArrayDataSource_;
  ::xsd::cxx::tree::one< name_type > name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ImportTypeEntry_Type schema type.
 *
 * @nosubgrouping
 */
class ImportTypeEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name localName
   *
   * @brief Accessor and modifier functions for the %localName
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string localName_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< localName_type, char > localName_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const localName_type&
  localName () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  localName_type&
  localName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  localName (const localName_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  localName (::std::unique_ptr< localName_type > p);

  //@}

  /**
   * @name remoteName
   *
   * @brief Accessor and modifier functions for the %remoteName
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string remoteName_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< remoteName_type, char > remoteName_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const remoteName_type&
  remoteName () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  remoteName_type&
  remoteName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  remoteName (const remoteName_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  remoteName (::std::unique_ptr< remoteName_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ImportTypeEntry_Type (const localName_type&,
                        const remoteName_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ImportTypeEntry_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ImportTypeEntry_Type (const ImportTypeEntry_Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ImportTypeEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ImportTypeEntry_Type&
  operator= (const ImportTypeEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ImportTypeEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< localName_type > localName_;
  ::xsd::cxx::tree::one< remoteName_type > remoteName_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ImportEvaluatorEntry_Type schema type.
 *
 * @nosubgrouping
 */
class ImportEvaluatorEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name localName
   *
   * @brief Accessor and modifier functions for the %localName
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string localName_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< localName_type, char > localName_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const localName_type&
  localName () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  localName_type&
  localName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  localName (const localName_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  localName (::std::unique_ptr< localName_type > p);

  //@}

  /**
   * @name remoteName
   *
   * @brief Accessor and modifier functions for the %remoteName
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string remoteName_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< remoteName_type, char > remoteName_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const remoteName_type&
  remoteName () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  remoteName_type&
  remoteName ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  remoteName (const remoteName_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  remoteName (::std::unique_ptr< remoteName_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ImportEvaluatorEntry_Type (const localName_type&,
                             const remoteName_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ImportEvaluatorEntry_Type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ImportEvaluatorEntry_Type (const ImportEvaluatorEntry_Type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ImportEvaluatorEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ImportEvaluatorEntry_Type&
  operator= (const ImportEvaluatorEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ImportEvaluatorEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< localName_type > localName_;
  ::xsd::cxx::tree::one< remoteName_type > remoteName_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Import_Type schema type.
 *
 * @nosubgrouping
 */
class Import_Type: public ::xml_schema::type
{
  public:
  /**
   * @name ImportType
   *
   * @brief Accessor and modifier functions for the %ImportType
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ImportTypeEntry_Type ImportType_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ImportType_type > ImportType_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ImportType_sequence::iterator ImportType_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ImportType_sequence::const_iterator ImportType_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ImportType_type, char > ImportType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ImportType_sequence&
  ImportType () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ImportType_sequence&
  ImportType ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ImportType (const ImportType_sequence& s);

  //@}

  /**
   * @name ImportEvaluator
   *
   * @brief Accessor and modifier functions for the %ImportEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ImportEvaluatorEntry_Type ImportEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ImportEvaluator_type > ImportEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ImportEvaluator_sequence::iterator ImportEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ImportEvaluator_sequence::const_iterator ImportEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ImportEvaluator_type, char > ImportEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ImportEvaluator_sequence&
  ImportEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ImportEvaluator_sequence&
  ImportEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ImportEvaluator (const ImportEvaluator_sequence& s);

  //@}

  /**
   * @name href
   *
   * @brief Accessor and modifier functions for the %href
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::uri href_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< href_type, char > href_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const href_type&
  href () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  href_type&
  href ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  href (const href_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  href (::std::unique_ptr< href_type > p);

  //@}

  /**
   * @name region
   *
   * @brief Accessor and modifier functions for the %region
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string region_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< region_type, char > region_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const region_type&
  region () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  region_type&
  region ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  region (const region_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  region (::std::unique_ptr< region_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Import_Type (const href_type&,
               const region_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Import_Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Import_Type (const Import_Type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Import_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Import_Type&
  operator= (const Import_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Import_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ImportType_sequence ImportType_;
  ImportEvaluator_sequence ImportEvaluator_;
  ::xsd::cxx::tree::one< href_type > href_;
  ::xsd::cxx::tree::one< region_type > region_;

  //@endcond
};

/**
 * @brief Class corresponding to the %NumberedIndexEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class NumberedIndexEvaluator_Type: public ::xml_schema::type
{
  public:
  /**
   * @name evaluator
   *
   * @brief Accessor and modifier functions for the %evaluator
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string evaluator_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const evaluator_type&
  evaluator () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  evaluator_type&
  evaluator ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  evaluator (const evaluator_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  //@}

  /**
   * @name indexNumber
   *
   * @brief Accessor and modifier functions for the %indexNumber
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer indexNumber_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< indexNumber_type, char > indexNumber_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const indexNumber_type&
  indexNumber () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  indexNumber_type&
  indexNumber ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  indexNumber (const indexNumber_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  NumberedIndexEvaluator_Type (const evaluator_type&,
                               const indexNumber_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  NumberedIndexEvaluator_Type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  NumberedIndexEvaluator_Type (const NumberedIndexEvaluator_Type& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual NumberedIndexEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  NumberedIndexEvaluator_Type&
  operator= (const NumberedIndexEvaluator_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~NumberedIndexEvaluator_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
  ::xsd::cxx::tree::one< indexNumber_type > indexNumber_;

  //@endcond
};

/**
 * @brief Class corresponding to the %NumberedIndexEvaluatorList_Type schema type.
 *
 * @nosubgrouping
 */
class NumberedIndexEvaluatorList_Type: public ::xml_schema::type
{
  public:
  /**
   * @name IndexEvaluator
   *
   * @brief Accessor and modifier functions for the %IndexEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::NumberedIndexEvaluator_Type IndexEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< IndexEvaluator_type > IndexEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef IndexEvaluator_sequence::iterator IndexEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef IndexEvaluator_sequence::const_iterator IndexEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< IndexEvaluator_type, char > IndexEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const IndexEvaluator_sequence&
  IndexEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  IndexEvaluator_sequence&
  IndexEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  IndexEvaluator (const IndexEvaluator_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  NumberedIndexEvaluatorList_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  NumberedIndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  NumberedIndexEvaluatorList_Type (const NumberedIndexEvaluatorList_Type& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual NumberedIndexEvaluatorList_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  NumberedIndexEvaluatorList_Type&
  operator= (const NumberedIndexEvaluatorList_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~NumberedIndexEvaluatorList_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  IndexEvaluator_sequence IndexEvaluator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %BindMapEntry_Type schema type.
 *
 * @nosubgrouping
 */
class BindMapEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name argument
   *
   * @brief Accessor and modifier functions for the %argument
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string argument_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< argument_type, char > argument_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const argument_type&
  argument () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  argument_type&
  argument ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  argument (const argument_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  argument (::std::unique_ptr< argument_type > p);

  //@}

  /**
   * @name source
   *
   * @brief Accessor and modifier functions for the %source
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string source_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< source_type, char > source_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const source_type&
  source () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  source_type&
  source ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  source (const source_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  source (::std::unique_ptr< source_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  BindMapEntry_Type (const argument_type&,
                     const source_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BindMapEntry_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BindMapEntry_Type (const BindMapEntry_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual BindMapEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BindMapEntry_Type&
  operator= (const BindMapEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~BindMapEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< argument_type > argument_;
  ::xsd::cxx::tree::one< source_type > source_;

  //@endcond
};

/**
 * @brief Class corresponding to the %BindMapIndexEntry_Type schema type.
 *
 * @nosubgrouping
 */
class BindMapIndexEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name argument
   *
   * @brief Accessor and modifier functions for the %argument
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string argument_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< argument_type, char > argument_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const argument_type&
  argument () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  argument_type&
  argument ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  argument (const argument_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  argument (::std::unique_ptr< argument_type > p);

  //@}

  /**
   * @name indexNumber
   *
   * @brief Accessor and modifier functions for the %indexNumber
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer indexNumber_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< indexNumber_type, char > indexNumber_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const indexNumber_type&
  indexNumber () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  indexNumber_type&
  indexNumber ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  indexNumber (const indexNumber_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  BindMapIndexEntry_Type (const argument_type&,
                          const indexNumber_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BindMapIndexEntry_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BindMapIndexEntry_Type (const BindMapIndexEntry_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual BindMapIndexEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BindMapIndexEntry_Type&
  operator= (const BindMapIndexEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~BindMapIndexEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< argument_type > argument_;
  ::xsd::cxx::tree::one< indexNumber_type > indexNumber_;

  //@endcond
};

/**
 * @brief Class corresponding to the %BindMapWithIndexes_Type schema type.
 *
 * @nosubgrouping
 */
class BindMapWithIndexes_Type: public ::xml_schema::type
{
  public:
  /**
   * @name BindIndex
   *
   * @brief Accessor and modifier functions for the %BindIndex
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BindMapIndexEntry_Type BindIndex_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< BindIndex_type > BindIndex_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef BindIndex_sequence::iterator BindIndex_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef BindIndex_sequence::const_iterator BindIndex_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< BindIndex_type, char > BindIndex_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const BindIndex_sequence&
  BindIndex () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  BindIndex_sequence&
  BindIndex ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  BindIndex (const BindIndex_sequence& s);

  //@}

  /**
   * @name Bind
   *
   * @brief Accessor and modifier functions for the %Bind
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BindMapEntry_Type Bind_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Bind_type > Bind_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Bind_sequence::iterator Bind_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Bind_sequence::const_iterator Bind_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Bind_type, char > Bind_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Bind_sequence&
  Bind () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Bind_sequence&
  Bind ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Bind (const Bind_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  BindMapWithIndexes_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BindMapWithIndexes_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BindMapWithIndexes_Type (const BindMapWithIndexes_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual BindMapWithIndexes_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BindMapWithIndexes_Type&
  operator= (const BindMapWithIndexes_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~BindMapWithIndexes_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  BindIndex_sequence BindIndex_;
  Bind_sequence Bind_;

  //@endcond
};

/**
 * @brief Class corresponding to the %BindMap_Type schema type.
 *
 * @nosubgrouping
 */
class BindMap_Type: public ::xml_schema::type
{
  public:
  /**
   * @name Bind
   *
   * @brief Accessor and modifier functions for the %Bind
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BindMapEntry_Type Bind_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Bind_type > Bind_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Bind_sequence::iterator Bind_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Bind_sequence::const_iterator Bind_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Bind_type, char > Bind_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Bind_sequence&
  Bind () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Bind_sequence&
  Bind ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Bind (const Bind_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  BindMap_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BindMap_Type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BindMap_Type (const BindMap_Type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual BindMap_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BindMap_Type&
  operator= (const BindMap_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~BindMap_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Bind_sequence Bind_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ComponentEvaluatorsEntry_Type schema type.
 *
 * @nosubgrouping
 */
class ComponentEvaluatorsEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name component
   *
   * @brief Accessor and modifier functions for the %component
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer component_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< component_type, char > component_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const component_type&
  component () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  component_type&
  component ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  component (const component_type& x);

  //@}

  /**
   * @name evaluator
   *
   * @brief Accessor and modifier functions for the %evaluator
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string evaluator_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const evaluator_type&
  evaluator () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  evaluator_type&
  evaluator ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  evaluator (const evaluator_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ComponentEvaluatorsEntry_Type (const component_type&,
                                 const evaluator_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ComponentEvaluatorsEntry_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ComponentEvaluatorsEntry_Type (const ComponentEvaluatorsEntry_Type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ComponentEvaluatorsEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ComponentEvaluatorsEntry_Type&
  operator= (const ComponentEvaluatorsEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ComponentEvaluatorsEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< component_type > component_;
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ComponentEvaluators_Type schema type.
 *
 * @nosubgrouping
 */
class ComponentEvaluators_Type: public ::xml_schema::type
{
  public:
  /**
   * @name ComponentEvaluator
   *
   * @brief Accessor and modifier functions for the %ComponentEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ComponentEvaluatorsEntry_Type ComponentEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ComponentEvaluator_type > ComponentEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ComponentEvaluator_sequence::iterator ComponentEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ComponentEvaluator_sequence::const_iterator ComponentEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ComponentEvaluator_type, char > ComponentEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ComponentEvaluator_sequence&
  ComponentEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ComponentEvaluator_sequence&
  ComponentEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ComponentEvaluator (const ComponentEvaluator_sequence& s);

  //@}

  /**
   * @name default
   *
   * @brief Accessor and modifier functions for the %default
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string default_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< default_type > default_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< default_type, char > default_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_optional&
  default_ () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_optional&
  default_ ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  default_ (const default_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  default_ (const default_optional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  default_ (::std::unique_ptr< default_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ComponentEvaluators_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ComponentEvaluators_Type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ComponentEvaluators_Type (const ComponentEvaluators_Type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ComponentEvaluators_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ComponentEvaluators_Type&
  operator= (const ComponentEvaluators_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ComponentEvaluators_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ComponentEvaluator_sequence ComponentEvaluator_;
  default_optional default__;

  //@endcond
};

/**
 * @brief Class corresponding to the %ShapeMap_Type schema type.
 *
 * @nosubgrouping
 */
class ShapeMap_Type: public ::xml_schema::type
{
  public:
  /**
   * @name evaluator
   *
   * @brief Accessor and modifier functions for the %evaluator
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string evaluator_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const evaluator_type&
  evaluator () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  evaluator_type&
  evaluator ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  evaluator (const evaluator_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ShapeMap_Type (const evaluator_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ShapeMap_Type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ShapeMap_Type (const ShapeMap_Type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ShapeMap_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ShapeMap_Type&
  operator= (const ShapeMap_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ShapeMap_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ArgumentListEntry_Type schema type.
 *
 * @nosubgrouping
 */
class ArgumentListEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const name_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< name_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ArgumentListEntry_Type (const name_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArgumentListEntry_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArgumentListEntry_Type (const ArgumentListEntry_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ArgumentListEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArgumentListEntry_Type&
  operator= (const ArgumentListEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ArgumentListEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< name_type > name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ArgumentList_Type schema type.
 *
 * @nosubgrouping
 */
class ArgumentList_Type: public ::xml_schema::type
{
  public:
  /**
   * @name Argument
   *
   * @brief Accessor and modifier functions for the %Argument
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ArgumentListEntry_Type Argument_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Argument_type > Argument_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Argument_sequence::iterator Argument_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Argument_sequence::const_iterator Argument_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Argument_type, char > Argument_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Argument_sequence&
  Argument () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Argument_sequence&
  Argument ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Argument (const Argument_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ArgumentList_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArgumentList_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArgumentList_Type (const ArgumentList_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ArgumentList_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArgumentList_Type&
  operator= (const ArgumentList_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ArgumentList_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Argument_sequence Argument_;

  //@endcond
};

/**
 * @brief Class corresponding to the %EvaluatorListEntry_Type schema type.
 *
 * @nosubgrouping
 */
class EvaluatorListEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name evaluator
   *
   * @brief Accessor and modifier functions for the %evaluator
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string evaluator_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const evaluator_type&
  evaluator () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  evaluator_type&
  evaluator ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  evaluator (const evaluator_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  EvaluatorListEntry_Type (const evaluator_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EvaluatorListEntry_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EvaluatorListEntry_Type (const EvaluatorListEntry_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EvaluatorListEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EvaluatorListEntry_Type&
  operator= (const EvaluatorListEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~EvaluatorListEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %IndexEvaluatorList_Type schema type.
 *
 * @nosubgrouping
 */
class IndexEvaluatorList_Type: public ::xml_schema::type
{
  public:
  /**
   * @name IndexEvaluator
   *
   * @brief Accessor and modifier functions for the %IndexEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::EvaluatorListEntry_Type IndexEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< IndexEvaluator_type > IndexEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef IndexEvaluator_sequence::iterator IndexEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef IndexEvaluator_sequence::const_iterator IndexEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< IndexEvaluator_type, char > IndexEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const IndexEvaluator_sequence&
  IndexEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  IndexEvaluator_sequence&
  IndexEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  IndexEvaluator (const IndexEvaluator_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  IndexEvaluatorList_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  IndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  IndexEvaluatorList_Type (const IndexEvaluatorList_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual IndexEvaluatorList_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  IndexEvaluatorList_Type&
  operator= (const IndexEvaluatorList_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~IndexEvaluatorList_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  IndexEvaluator_sequence IndexEvaluator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %OrderedEvaluatorListEntry_Type schema type.
 *
 * @nosubgrouping
 */
class OrderedEvaluatorListEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name evaluator
   *
   * @brief Accessor and modifier functions for the %evaluator
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string evaluator_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const evaluator_type&
  evaluator () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  evaluator_type&
  evaluator ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  evaluator (const evaluator_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  //@}

  /**
   * @name order
   *
   * @brief Accessor and modifier functions for the %order
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string order_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< order_type > order_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< order_type, char > order_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const order_optional&
  order () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  order_optional&
  order ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  order (const order_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  order (const order_optional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  order (::std::unique_ptr< order_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  OrderedEvaluatorListEntry_Type (const evaluator_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OrderedEvaluatorListEntry_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OrderedEvaluatorListEntry_Type (const OrderedEvaluatorListEntry_Type& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual OrderedEvaluatorListEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OrderedEvaluatorListEntry_Type&
  operator= (const OrderedEvaluatorListEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~OrderedEvaluatorListEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;
  order_optional order_;

  //@endcond
};

/**
 * @brief Class corresponding to the %OrderedIndexEvaluatorList_Type schema type.
 *
 * @nosubgrouping
 */
class OrderedIndexEvaluatorList_Type: public ::xml_schema::type
{
  public:
  /**
   * @name IndexEvaluator
   *
   * @brief Accessor and modifier functions for the %IndexEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::OrderedEvaluatorListEntry_Type IndexEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< IndexEvaluator_type > IndexEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef IndexEvaluator_sequence::iterator IndexEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef IndexEvaluator_sequence::const_iterator IndexEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< IndexEvaluator_type, char > IndexEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const IndexEvaluator_sequence&
  IndexEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  IndexEvaluator_sequence&
  IndexEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  IndexEvaluator (const IndexEvaluator_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  OrderedIndexEvaluatorList_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OrderedIndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OrderedIndexEvaluatorList_Type (const OrderedIndexEvaluatorList_Type& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual OrderedIndexEvaluatorList_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OrderedIndexEvaluatorList_Type&
  operator= (const OrderedIndexEvaluatorList_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~OrderedIndexEvaluatorList_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  IndexEvaluator_sequence IndexEvaluator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %MemberRange_Type schema type.
 *
 * @nosubgrouping
 */
class MemberRange_Type: public ::xml_schema::type
{
  public:
  /**
   * @name min
   *
   * @brief Accessor and modifier functions for the %min
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer min_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< min_type, char > min_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const min_type&
  min () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  min_type&
  min ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  min (const min_type& x);

  //@}

  /**
   * @name max
   *
   * @brief Accessor and modifier functions for the %max
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer max_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const max_type&
  max () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  max_type&
  max ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  max (const max_type& x);

  //@}

  /**
   * @name stride
   *
   * @brief Accessor and modifier functions for the %stride
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer stride_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< stride_type > stride_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< stride_type, char > stride_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const stride_optional&
  stride () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  stride_optional&
  stride ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  stride (const stride_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  stride (const stride_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  MemberRange_Type (const min_type&,
                    const max_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MemberRange_Type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MemberRange_Type (const MemberRange_Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual MemberRange_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MemberRange_Type&
  operator= (const MemberRange_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~MemberRange_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< min_type > min_;
  ::xsd::cxx::tree::one< max_type > max_;
  stride_optional stride_;

  //@endcond
};

/**
 * @brief Class corresponding to the %MemberData_Type schema type.
 *
 * @nosubgrouping
 */
class MemberData_Type: public ::xml_schema::type
{
  public:
  /**
   * @name count
   *
   * @brief Accessor and modifier functions for the %count
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer count_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const count_type&
  count () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  count_type&
  count ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  count (const count_type& x);

  //@}

  /**
   * @name data
   *
   * @brief Accessor and modifier functions for the %data
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string data_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< data_type, char > data_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const data_type&
  data () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  data_type&
  data ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  data (const data_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  data (::std::unique_ptr< data_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  MemberData_Type (const count_type&,
                   const data_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MemberData_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MemberData_Type (const MemberData_Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual MemberData_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MemberData_Type&
  operator= (const MemberData_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~MemberData_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< count_type > count_;
  ::xsd::cxx::tree::one< data_type > data_;

  //@endcond
};

/**
 * @brief Class corresponding to the %EnsembleMembers_Type schema type.
 *
 * @nosubgrouping
 */
class EnsembleMembers_Type: public ::xml_schema::type
{
  public:
  /**
   * @name MemberListData
   *
   * @brief Accessor and modifier functions for the %MemberListData
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MemberData_Type MemberListData_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MemberListData_type > MemberListData_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< MemberListData_type, char > MemberListData_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MemberListData_optional&
  MemberListData () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  MemberListData_optional&
  MemberListData ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  MemberListData (const MemberListData_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  MemberListData (const MemberListData_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  MemberListData (::std::unique_ptr< MemberListData_type > p);

  //@}

  /**
   * @name MemberRangeData
   *
   * @brief Accessor and modifier functions for the %MemberRangeData
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MemberData_Type MemberRangeData_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MemberRangeData_type > MemberRangeData_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< MemberRangeData_type, char > MemberRangeData_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MemberRangeData_optional&
  MemberRangeData () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  MemberRangeData_optional&
  MemberRangeData ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  MemberRangeData (const MemberRangeData_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  MemberRangeData (const MemberRangeData_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  MemberRangeData (::std::unique_ptr< MemberRangeData_type > p);

  //@}

  /**
   * @name MemberStrideRangeData
   *
   * @brief Accessor and modifier functions for the %MemberStrideRangeData
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MemberData_Type MemberStrideRangeData_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MemberStrideRangeData_type > MemberStrideRangeData_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< MemberStrideRangeData_type, char > MemberStrideRangeData_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MemberStrideRangeData_optional&
  MemberStrideRangeData () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  MemberStrideRangeData_optional&
  MemberStrideRangeData ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  MemberStrideRangeData (const MemberStrideRangeData_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  MemberStrideRangeData (const MemberStrideRangeData_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  MemberStrideRangeData (::std::unique_ptr< MemberStrideRangeData_type > p);

  //@}

  /**
   * @name MemberRange
   *
   * @brief Accessor and modifier functions for the %MemberRange
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MemberRange_Type MemberRange_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MemberRange_type > MemberRange_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< MemberRange_type, char > MemberRange_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MemberRange_optional&
  MemberRange () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  MemberRange_optional&
  MemberRange ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  MemberRange (const MemberRange_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  MemberRange (const MemberRange_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  MemberRange (::std::unique_ptr< MemberRange_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  EnsembleMembers_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnsembleMembers_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnsembleMembers_Type (const EnsembleMembers_Type& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnsembleMembers_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnsembleMembers_Type&
  operator= (const EnsembleMembers_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~EnsembleMembers_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  MemberListData_optional MemberListData_;
  MemberRangeData_optional MemberRangeData_;
  MemberStrideRangeData_optional MemberStrideRangeData_;
  MemberRange_optional MemberRange_;

  //@endcond
};

/**
 * @brief Class corresponding to the %BooleanType_Type schema type.
 *
 * @nosubgrouping
 */
class BooleanType_Type: public ::FieldmlObject_Type
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  BooleanType_Type (const name_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BooleanType_Type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BooleanType_Type (const BooleanType_Type& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual BooleanType_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~BooleanType_Type ();
};

/**
 * @brief Class corresponding to the %EnsembleType_Type schema type.
 *
 * @nosubgrouping
 */
class EnsembleType_Type: public ::FieldmlObject_Type
{
  public:
  /**
   * @name Members
   *
   * @brief Accessor and modifier functions for the %Members
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::EnsembleMembers_Type Members_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Members_type, char > Members_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Members_type&
  Members () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Members_type&
  Members ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Members (const Members_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Members (::std::unique_ptr< Members_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  EnsembleType_Type (const name_type&,
                     const Members_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  EnsembleType_Type (const name_type&,
                     ::std::unique_ptr< Members_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EnsembleType_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnsembleType_Type (const EnsembleType_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EnsembleType_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EnsembleType_Type&
  operator= (const EnsembleType_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~EnsembleType_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Members_type > Members_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ContinuousComponent_Type schema type.
 *
 * @nosubgrouping
 */
class ContinuousComponent_Type: public ::xml_schema::type
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const name_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< name_type > p);

  //@}

  /**
   * @name count
   *
   * @brief Accessor and modifier functions for the %count
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::positive_integer count_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< count_type, char > count_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const count_type&
  count () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  count_type&
  count ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  count (const count_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ContinuousComponent_Type (const name_type&,
                            const count_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ContinuousComponent_Type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ContinuousComponent_Type (const ContinuousComponent_Type& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ContinuousComponent_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ContinuousComponent_Type&
  operator= (const ContinuousComponent_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ContinuousComponent_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< count_type > count_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ContinuousType_Type schema type.
 *
 * @nosubgrouping
 */
class ContinuousType_Type: public ::FieldmlObject_Type
{
  public:
  /**
   * @name Components
   *
   * @brief Accessor and modifier functions for the %Components
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ContinuousComponent_Type Components_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Components_type > Components_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Components_type, char > Components_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Components_optional&
  Components () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Components_optional&
  Components ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Components (const Components_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Components (const Components_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Components (::std::unique_ptr< Components_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ContinuousType_Type (const name_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ContinuousType_Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ContinuousType_Type (const ContinuousType_Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ContinuousType_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ContinuousType_Type&
  operator= (const ContinuousType_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ContinuousType_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Components_optional Components_;

  //@endcond
};

/**
 * @brief Class corresponding to the %MeshType_Type schema type.
 *
 * @nosubgrouping
 */
class MeshType_Type: public ::FieldmlObject_Type
{
  public:
  /**
   * @name Elements
   *
   * @brief Accessor and modifier functions for the %Elements
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::EnsembleType_Type Elements_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Elements_type, char > Elements_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Elements_type&
  Elements () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Elements_type&
  Elements ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Elements (const Elements_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Elements (::std::unique_ptr< Elements_type > p);

  //@}

  /**
   * @name Chart
   *
   * @brief Accessor and modifier functions for the %Chart
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ContinuousType_Type Chart_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Chart_type, char > Chart_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Chart_type&
  Chart () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Chart_type&
  Chart ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Chart (const Chart_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Chart (::std::unique_ptr< Chart_type > p);

  //@}

  /**
   * @name Shapes
   *
   * @brief Accessor and modifier functions for the %Shapes
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ShapeMap_Type Shapes_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Shapes_type, char > Shapes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Shapes_type&
  Shapes () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Shapes_type&
  Shapes ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Shapes (const Shapes_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Shapes (::std::unique_ptr< Shapes_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  MeshType_Type (const name_type&,
                 const Elements_type&,
                 const Chart_type&,
                 const Shapes_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  MeshType_Type (const name_type&,
                 ::std::unique_ptr< Elements_type >,
                 ::std::unique_ptr< Chart_type >,
                 ::std::unique_ptr< Shapes_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  MeshType_Type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MeshType_Type (const MeshType_Type& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual MeshType_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  MeshType_Type&
  operator= (const MeshType_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~MeshType_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Elements_type > Elements_;
  ::xsd::cxx::tree::one< Chart_type > Chart_;
  ::xsd::cxx::tree::one< Shapes_type > Shapes_;

  //@endcond
};

/**
 * @brief Class corresponding to the %FieldmlEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class FieldmlEvaluator_Type: public ::FieldmlObject_Type
{
  public:
  /**
   * @name Arguments
   *
   * @brief Accessor and modifier functions for the %Arguments
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ArgumentList_Type Arguments_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Arguments_type > Arguments_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Arguments_type, char > Arguments_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Arguments_optional&
  Arguments () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Arguments_optional&
  Arguments ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Arguments (const Arguments_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Arguments (const Arguments_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Arguments (::std::unique_ptr< Arguments_type > p);

  //@}

  /**
   * @name valueType
   *
   * @brief Accessor and modifier functions for the %valueType
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string valueType_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< valueType_type, char > valueType_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const valueType_type&
  valueType () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  valueType_type&
  valueType ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  valueType (const valueType_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  valueType (::std::unique_ptr< valueType_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  FieldmlEvaluator_Type (const name_type&,
                         const valueType_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  FieldmlEvaluator_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FieldmlEvaluator_Type (const FieldmlEvaluator_Type& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual FieldmlEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  FieldmlEvaluator_Type&
  operator= (const FieldmlEvaluator_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~FieldmlEvaluator_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Arguments_optional Arguments_;
  ::xsd::cxx::tree::one< valueType_type > valueType_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ArgumentEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class ArgumentEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ArgumentEvaluator_Type (const name_type&,
                          const valueType_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ArgumentEvaluator_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ArgumentEvaluator_Type (const ArgumentEvaluator_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ArgumentEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ArgumentEvaluator_Type ();
};

/**
 * @brief Class corresponding to the %ExternalEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class ExternalEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ExternalEvaluator_Type (const name_type&,
                          const valueType_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ExternalEvaluator_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ExternalEvaluator_Type (const ExternalEvaluator_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ExternalEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ExternalEvaluator_Type ();
};

/**
 * @brief Class corresponding to the %ConstantEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class ConstantEvaluator_Type: public ::FieldmlObject_Type
{
  public:
  /**
   * @name value
   *
   * @brief Accessor and modifier functions for the %value
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string value_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const value_type&
  value () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  value_type&
  value ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  value (const value_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  value (::std::unique_ptr< value_type > p);

  //@}

  /**
   * @name valueType
   *
   * @brief Accessor and modifier functions for the %valueType
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string valueType_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< valueType_type, char > valueType_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const valueType_type&
  valueType () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  valueType_type&
  valueType ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  valueType (const valueType_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  valueType (::std::unique_ptr< valueType_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ConstantEvaluator_Type (const name_type&,
                          const value_type&,
                          const valueType_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ConstantEvaluator_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ConstantEvaluator_Type (const ConstantEvaluator_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ConstantEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ConstantEvaluator_Type&
  operator= (const ConstantEvaluator_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ConstantEvaluator_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< valueType_type > valueType_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ReferenceEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class ReferenceEvaluator_Type: public ::FieldmlObject_Type
{
  public:
  /**
   * @name Arguments
   *
   * @brief Accessor and modifier functions for the %Arguments
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ArgumentList_Type Arguments_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Arguments_type > Arguments_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Arguments_type, char > Arguments_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Arguments_optional&
  Arguments () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Arguments_optional&
  Arguments ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Arguments (const Arguments_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Arguments (const Arguments_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Arguments (::std::unique_ptr< Arguments_type > p);

  //@}

  /**
   * @name Bindings
   *
   * @brief Accessor and modifier functions for the %Bindings
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BindMap_Type Bindings_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Bindings_type > Bindings_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Bindings_type, char > Bindings_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Bindings_optional&
  Bindings () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Bindings_optional&
  Bindings ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Bindings (const Bindings_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Bindings (const Bindings_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Bindings (::std::unique_ptr< Bindings_type > p);

  //@}

  /**
   * @name valueType
   *
   * @brief Accessor and modifier functions for the %valueType
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string valueType_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< valueType_type > valueType_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< valueType_type, char > valueType_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const valueType_optional&
  valueType () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  valueType_optional&
  valueType ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  valueType (const valueType_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  valueType (const valueType_optional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  valueType (::std::unique_ptr< valueType_type > p);

  //@}

  /**
   * @name evaluator
   *
   * @brief Accessor and modifier functions for the %evaluator
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string evaluator_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const evaluator_type&
  evaluator () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  evaluator_type&
  evaluator ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  evaluator (const evaluator_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ReferenceEvaluator_Type (const name_type&,
                           const evaluator_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ReferenceEvaluator_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ReferenceEvaluator_Type (const ReferenceEvaluator_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ReferenceEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ReferenceEvaluator_Type&
  operator= (const ReferenceEvaluator_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ReferenceEvaluator_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Arguments_optional Arguments_;
  Bindings_optional Bindings_;
  valueType_optional valueType_;
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %EvaluatorMapEntry_Type schema type.
 *
 * @nosubgrouping
 */
class EvaluatorMapEntry_Type: public ::xml_schema::type
{
  public:
  /**
   * @name value
   *
   * @brief Accessor and modifier functions for the %value
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::non_negative_integer value_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const value_type&
  value () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  value_type&
  value ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  value (const value_type& x);

  //@}

  /**
   * @name evaluator
   *
   * @brief Accessor and modifier functions for the %evaluator
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string evaluator_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< evaluator_type, char > evaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const evaluator_type&
  evaluator () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  evaluator_type&
  evaluator ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  evaluator (const evaluator_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  evaluator (::std::unique_ptr< evaluator_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  EvaluatorMapEntry_Type (const value_type&,
                          const evaluator_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EvaluatorMapEntry_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EvaluatorMapEntry_Type (const EvaluatorMapEntry_Type& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EvaluatorMapEntry_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EvaluatorMapEntry_Type&
  operator= (const EvaluatorMapEntry_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~EvaluatorMapEntry_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< value_type > value_;
  ::xsd::cxx::tree::one< evaluator_type > evaluator_;

  //@endcond
};

/**
 * @brief Class corresponding to the %EvaluatorMap_Type schema type.
 *
 * @nosubgrouping
 */
class EvaluatorMap_Type: public ::xml_schema::type
{
  public:
  /**
   * @name EvaluatorMapEntry
   *
   * @brief Accessor and modifier functions for the %EvaluatorMapEntry
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::EvaluatorMapEntry_Type EvaluatorMapEntry_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< EvaluatorMapEntry_type > EvaluatorMapEntry_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef EvaluatorMapEntry_sequence::iterator EvaluatorMapEntry_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef EvaluatorMapEntry_sequence::const_iterator EvaluatorMapEntry_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< EvaluatorMapEntry_type, char > EvaluatorMapEntry_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const EvaluatorMapEntry_sequence&
  EvaluatorMapEntry () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  EvaluatorMapEntry_sequence&
  EvaluatorMapEntry ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  EvaluatorMapEntry (const EvaluatorMapEntry_sequence& s);

  //@}

  /**
   * @name default
   *
   * @brief Accessor and modifier functions for the %default
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string default_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< default_type > default_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< default_type, char > default_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const default_optional&
  default_ () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  default_optional&
  default_ ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  default_ (const default_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  default_ (const default_optional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  default_ (::std::unique_ptr< default_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  EvaluatorMap_Type ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  EvaluatorMap_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EvaluatorMap_Type (const EvaluatorMap_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual EvaluatorMap_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  EvaluatorMap_Type&
  operator= (const EvaluatorMap_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~EvaluatorMap_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  EvaluatorMapEntry_sequence EvaluatorMapEntry_;
  default_optional default__;

  //@endcond
};

/**
 * @brief Class corresponding to the %PiecewiseEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class PiecewiseEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  /**
   * @name Bindings
   *
   * @brief Accessor and modifier functions for the %Bindings
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BindMap_Type Bindings_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Bindings_type > Bindings_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Bindings_type, char > Bindings_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Bindings_optional&
  Bindings () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Bindings_optional&
  Bindings ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Bindings (const Bindings_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Bindings (const Bindings_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Bindings (::std::unique_ptr< Bindings_type > p);

  //@}

  /**
   * @name IndexEvaluators
   *
   * @brief Accessor and modifier functions for the %IndexEvaluators
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::NumberedIndexEvaluatorList_Type IndexEvaluators_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< IndexEvaluators_type > IndexEvaluators_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< IndexEvaluators_type, char > IndexEvaluators_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const IndexEvaluators_optional&
  IndexEvaluators () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  IndexEvaluators_optional&
  IndexEvaluators ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  IndexEvaluators (const IndexEvaluators_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  IndexEvaluators (const IndexEvaluators_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  IndexEvaluators (::std::unique_ptr< IndexEvaluators_type > p);

  //@}

  /**
   * @name EvaluatorMap
   *
   * @brief Accessor and modifier functions for the %EvaluatorMap
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::EvaluatorMap_Type EvaluatorMap_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< EvaluatorMap_type, char > EvaluatorMap_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const EvaluatorMap_type&
  EvaluatorMap () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  EvaluatorMap_type&
  EvaluatorMap ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  EvaluatorMap (const EvaluatorMap_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  EvaluatorMap (::std::unique_ptr< EvaluatorMap_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  PiecewiseEvaluator_Type (const name_type&,
                           const valueType_type&,
                           const EvaluatorMap_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  PiecewiseEvaluator_Type (const name_type&,
                           const valueType_type&,
                           ::std::unique_ptr< EvaluatorMap_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  PiecewiseEvaluator_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  PiecewiseEvaluator_Type (const PiecewiseEvaluator_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual PiecewiseEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  PiecewiseEvaluator_Type&
  operator= (const PiecewiseEvaluator_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~PiecewiseEvaluator_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Bindings_optional Bindings_;
  IndexEvaluators_optional IndexEvaluators_;
  ::xsd::cxx::tree::one< EvaluatorMap_type > EvaluatorMap_;

  //@endcond
};

/**
 * @brief Class corresponding to the %DenseArrayData_Type schema type.
 *
 * @nosubgrouping
 */
class DenseArrayData_Type: public ::xml_schema::type
{
  public:
  /**
   * @name DenseIndexes
   *
   * @brief Accessor and modifier functions for the %DenseIndexes
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::OrderedIndexEvaluatorList_Type DenseIndexes_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DenseIndexes_type > DenseIndexes_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DenseIndexes_type, char > DenseIndexes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DenseIndexes_optional&
  DenseIndexes () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  DenseIndexes_optional&
  DenseIndexes ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DenseIndexes (const DenseIndexes_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  DenseIndexes (const DenseIndexes_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DenseIndexes (::std::unique_ptr< DenseIndexes_type > p);

  //@}

  /**
   * @name data
   *
   * @brief Accessor and modifier functions for the %data
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string data_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< data_type, char > data_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const data_type&
  data () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  data_type&
  data ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  data (const data_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  data (::std::unique_ptr< data_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DenseArrayData_Type (const data_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DenseArrayData_Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DenseArrayData_Type (const DenseArrayData_Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DenseArrayData_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DenseArrayData_Type&
  operator= (const DenseArrayData_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DenseArrayData_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DenseIndexes_optional DenseIndexes_;
  ::xsd::cxx::tree::one< data_type > data_;

  //@endcond
};

/**
 * @brief Class corresponding to the %DOKArrayData_Type schema type.
 *
 * @nosubgrouping
 */
class DOKArrayData_Type: public ::xml_schema::type
{
  public:
  /**
   * @name DenseIndexes
   *
   * @brief Accessor and modifier functions for the %DenseIndexes
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::OrderedIndexEvaluatorList_Type DenseIndexes_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DenseIndexes_type > DenseIndexes_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DenseIndexes_type, char > DenseIndexes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DenseIndexes_optional&
  DenseIndexes () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  DenseIndexes_optional&
  DenseIndexes ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DenseIndexes (const DenseIndexes_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  DenseIndexes (const DenseIndexes_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DenseIndexes (::std::unique_ptr< DenseIndexes_type > p);

  //@}

  /**
   * @name SparseIndexes
   *
   * @brief Accessor and modifier functions for the %SparseIndexes
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::IndexEvaluatorList_Type SparseIndexes_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< SparseIndexes_type, char > SparseIndexes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const SparseIndexes_type&
  SparseIndexes () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  SparseIndexes_type&
  SparseIndexes ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  SparseIndexes (const SparseIndexes_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  SparseIndexes (::std::unique_ptr< SparseIndexes_type > p);

  //@}

  /**
   * @name keyData
   *
   * @brief Accessor and modifier functions for the %keyData
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string keyData_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< keyData_type, char > keyData_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const keyData_type&
  keyData () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  keyData_type&
  keyData ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  keyData (const keyData_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  keyData (::std::unique_ptr< keyData_type > p);

  //@}

  /**
   * @name valueData
   *
   * @brief Accessor and modifier functions for the %valueData
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string valueData_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< valueData_type, char > valueData_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const valueData_type&
  valueData () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  valueData_type&
  valueData ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  valueData (const valueData_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  valueData (::std::unique_ptr< valueData_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DOKArrayData_Type (const SparseIndexes_type&,
                     const keyData_type&,
                     const valueData_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  DOKArrayData_Type (::std::unique_ptr< SparseIndexes_type >,
                     const keyData_type&,
                     const valueData_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DOKArrayData_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DOKArrayData_Type (const DOKArrayData_Type& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DOKArrayData_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DOKArrayData_Type&
  operator= (const DOKArrayData_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DOKArrayData_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DenseIndexes_optional DenseIndexes_;
  ::xsd::cxx::tree::one< SparseIndexes_type > SparseIndexes_;
  ::xsd::cxx::tree::one< keyData_type > keyData_;
  ::xsd::cxx::tree::one< valueData_type > valueData_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ParameterEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class ParameterEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  /**
   * @name DenseArrayData
   *
   * @brief Accessor and modifier functions for the %DenseArrayData
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DenseArrayData_Type DenseArrayData_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DenseArrayData_type > DenseArrayData_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DenseArrayData_type, char > DenseArrayData_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DenseArrayData_optional&
  DenseArrayData () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  DenseArrayData_optional&
  DenseArrayData ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DenseArrayData (const DenseArrayData_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  DenseArrayData (const DenseArrayData_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DenseArrayData (::std::unique_ptr< DenseArrayData_type > p);

  //@}

  /**
   * @name DOKArrayData
   *
   * @brief Accessor and modifier functions for the %DOKArrayData
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DOKArrayData_Type DOKArrayData_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< DOKArrayData_type > DOKArrayData_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DOKArrayData_type, char > DOKArrayData_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const DOKArrayData_optional&
  DOKArrayData () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  DOKArrayData_optional&
  DOKArrayData ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DOKArrayData (const DOKArrayData_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  DOKArrayData (const DOKArrayData_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DOKArrayData (::std::unique_ptr< DOKArrayData_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ParameterEvaluator_Type (const name_type&,
                           const valueType_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ParameterEvaluator_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParameterEvaluator_Type (const ParameterEvaluator_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ParameterEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParameterEvaluator_Type&
  operator= (const ParameterEvaluator_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ParameterEvaluator_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DenseArrayData_optional DenseArrayData_;
  DOKArrayData_optional DOKArrayData_;

  //@endcond
};

/**
 * @brief Class corresponding to the %AggregateEvaluator_Type schema type.
 *
 * @nosubgrouping
 */
class AggregateEvaluator_Type: public ::FieldmlEvaluator_Type
{
  public:
  /**
   * @name Bindings
   *
   * @brief Accessor and modifier functions for the %Bindings
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BindMapWithIndexes_Type Bindings_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< Bindings_type > Bindings_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Bindings_type, char > Bindings_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const Bindings_optional&
  Bindings () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  Bindings_optional&
  Bindings ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Bindings (const Bindings_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  Bindings (const Bindings_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Bindings (::std::unique_ptr< Bindings_type > p);

  //@}

  /**
   * @name ComponentEvaluators
   *
   * @brief Accessor and modifier functions for the %ComponentEvaluators
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ComponentEvaluators_Type ComponentEvaluators_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ComponentEvaluators_type, char > ComponentEvaluators_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const ComponentEvaluators_type&
  ComponentEvaluators () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  ComponentEvaluators_type&
  ComponentEvaluators ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  ComponentEvaluators (const ComponentEvaluators_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  ComponentEvaluators (::std::unique_ptr< ComponentEvaluators_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  AggregateEvaluator_Type (const name_type&,
                           const valueType_type&,
                           const ComponentEvaluators_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  AggregateEvaluator_Type (const name_type&,
                           const valueType_type&,
                           ::std::unique_ptr< ComponentEvaluators_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  AggregateEvaluator_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  AggregateEvaluator_Type (const AggregateEvaluator_Type& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual AggregateEvaluator_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  AggregateEvaluator_Type&
  operator= (const AggregateEvaluator_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~AggregateEvaluator_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Bindings_optional Bindings_;
  ::xsd::cxx::tree::one< ComponentEvaluators_type > ComponentEvaluators_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Region_Type schema type.
 *
 * @nosubgrouping
 */
class Region_Type: public ::FieldmlRdfTargetType
{
  public:
  /**
   * @name Import
   *
   * @brief Accessor and modifier functions for the %Import
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Import_Type Import_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Import_type > Import_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Import_sequence::iterator Import_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Import_sequence::const_iterator Import_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Import_type, char > Import_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Import_sequence&
  Import () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Import_sequence&
  Import ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Import (const Import_sequence& s);

  //@}

  /**
   * @name DataResource
   *
   * @brief Accessor and modifier functions for the %DataResource
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DataResource_Type DataResource_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< DataResource_type > DataResource_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef DataResource_sequence::iterator DataResource_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef DataResource_sequence::const_iterator DataResource_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DataResource_type, char > DataResource_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const DataResource_sequence&
  DataResource () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  DataResource_sequence&
  DataResource ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  DataResource (const DataResource_sequence& s);

  //@}

  /**
   * @name BooleanType
   *
   * @brief Accessor and modifier functions for the %BooleanType
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BooleanType_Type BooleanType_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< BooleanType_type > BooleanType_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef BooleanType_sequence::iterator BooleanType_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef BooleanType_sequence::const_iterator BooleanType_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< BooleanType_type, char > BooleanType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const BooleanType_sequence&
  BooleanType () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  BooleanType_sequence&
  BooleanType ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  BooleanType (const BooleanType_sequence& s);

  //@}

  /**
   * @name EnsembleType
   *
   * @brief Accessor and modifier functions for the %EnsembleType
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::EnsembleType_Type EnsembleType_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< EnsembleType_type > EnsembleType_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef EnsembleType_sequence::iterator EnsembleType_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef EnsembleType_sequence::const_iterator EnsembleType_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< EnsembleType_type, char > EnsembleType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const EnsembleType_sequence&
  EnsembleType () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  EnsembleType_sequence&
  EnsembleType ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  EnsembleType (const EnsembleType_sequence& s);

  //@}

  /**
   * @name ContinuousType
   *
   * @brief Accessor and modifier functions for the %ContinuousType
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ContinuousType_Type ContinuousType_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ContinuousType_type > ContinuousType_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ContinuousType_sequence::iterator ContinuousType_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ContinuousType_sequence::const_iterator ContinuousType_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ContinuousType_type, char > ContinuousType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ContinuousType_sequence&
  ContinuousType () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ContinuousType_sequence&
  ContinuousType ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ContinuousType (const ContinuousType_sequence& s);

  //@}

  /**
   * @name MeshType
   *
   * @brief Accessor and modifier functions for the %MeshType
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::MeshType_Type MeshType_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< MeshType_type > MeshType_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef MeshType_sequence::iterator MeshType_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef MeshType_sequence::const_iterator MeshType_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< MeshType_type, char > MeshType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const MeshType_sequence&
  MeshType () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  MeshType_sequence&
  MeshType ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  MeshType (const MeshType_sequence& s);

  //@}

  /**
   * @name ArgumentEvaluator
   *
   * @brief Accessor and modifier functions for the %ArgumentEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ArgumentEvaluator_Type ArgumentEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ArgumentEvaluator_type > ArgumentEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ArgumentEvaluator_sequence::iterator ArgumentEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ArgumentEvaluator_sequence::const_iterator ArgumentEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ArgumentEvaluator_type, char > ArgumentEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ArgumentEvaluator_sequence&
  ArgumentEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ArgumentEvaluator_sequence&
  ArgumentEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ArgumentEvaluator (const ArgumentEvaluator_sequence& s);

  //@}

  /**
   * @name ExternalEvaluator
   *
   * @brief Accessor and modifier functions for the %ExternalEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ExternalEvaluator_Type ExternalEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ExternalEvaluator_type > ExternalEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ExternalEvaluator_sequence::iterator ExternalEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ExternalEvaluator_sequence::const_iterator ExternalEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ExternalEvaluator_type, char > ExternalEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ExternalEvaluator_sequence&
  ExternalEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ExternalEvaluator_sequence&
  ExternalEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ExternalEvaluator (const ExternalEvaluator_sequence& s);

  //@}

  /**
   * @name ReferenceEvaluator
   *
   * @brief Accessor and modifier functions for the %ReferenceEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ReferenceEvaluator_Type ReferenceEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ReferenceEvaluator_type > ReferenceEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ReferenceEvaluator_sequence::iterator ReferenceEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ReferenceEvaluator_sequence::const_iterator ReferenceEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ReferenceEvaluator_type, char > ReferenceEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ReferenceEvaluator_sequence&
  ReferenceEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ReferenceEvaluator_sequence&
  ReferenceEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ReferenceEvaluator (const ReferenceEvaluator_sequence& s);

  //@}

  /**
   * @name ConstantEvaluator
   *
   * @brief Accessor and modifier functions for the %ConstantEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ConstantEvaluator_Type ConstantEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ConstantEvaluator_type > ConstantEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ConstantEvaluator_sequence::iterator ConstantEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ConstantEvaluator_sequence::const_iterator ConstantEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ConstantEvaluator_type, char > ConstantEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ConstantEvaluator_sequence&
  ConstantEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ConstantEvaluator_sequence&
  ConstantEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ConstantEvaluator (const ConstantEvaluator_sequence& s);

  //@}

  /**
   * @name PiecewiseEvaluator
   *
   * @brief Accessor and modifier functions for the %PiecewiseEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::PiecewiseEvaluator_Type PiecewiseEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< PiecewiseEvaluator_type > PiecewiseEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef PiecewiseEvaluator_sequence::iterator PiecewiseEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef PiecewiseEvaluator_sequence::const_iterator PiecewiseEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< PiecewiseEvaluator_type, char > PiecewiseEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const PiecewiseEvaluator_sequence&
  PiecewiseEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  PiecewiseEvaluator_sequence&
  PiecewiseEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  PiecewiseEvaluator (const PiecewiseEvaluator_sequence& s);

  //@}

  /**
   * @name ParameterEvaluator
   *
   * @brief Accessor and modifier functions for the %ParameterEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ParameterEvaluator_Type ParameterEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ParameterEvaluator_type > ParameterEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ParameterEvaluator_sequence::iterator ParameterEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ParameterEvaluator_sequence::const_iterator ParameterEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ParameterEvaluator_type, char > ParameterEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ParameterEvaluator_sequence&
  ParameterEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ParameterEvaluator_sequence&
  ParameterEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ParameterEvaluator (const ParameterEvaluator_sequence& s);

  //@}

  /**
   * @name AggregateEvaluator
   *
   * @brief Accessor and modifier functions for the %AggregateEvaluator
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::AggregateEvaluator_Type AggregateEvaluator_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AggregateEvaluator_type > AggregateEvaluator_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AggregateEvaluator_sequence::iterator AggregateEvaluator_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AggregateEvaluator_sequence::const_iterator AggregateEvaluator_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AggregateEvaluator_type, char > AggregateEvaluator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AggregateEvaluator_sequence&
  AggregateEvaluator () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AggregateEvaluator_sequence&
  AggregateEvaluator ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AggregateEvaluator (const AggregateEvaluator_sequence& s);

  //@}

  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute.
   *
   * @return A constant reference to the attribute.
   */
  const name_type&
  name () const;

  /**
   * @brief Return a read-write reference to the attribute.
   *
   * @return A reference to the attribute.
   */
  name_type&
  name ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  name (const name_type& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< name_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Region_Type (const name_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Region_Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Region_Type (const Region_Type& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Region_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Region_Type&
  operator= (const Region_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Region_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Import_sequence Import_;
  DataResource_sequence DataResource_;
  BooleanType_sequence BooleanType_;
  EnsembleType_sequence EnsembleType_;
  ContinuousType_sequence ContinuousType_;
  MeshType_sequence MeshType_;
  ArgumentEvaluator_sequence ArgumentEvaluator_;
  ExternalEvaluator_sequence ExternalEvaluator_;
  ReferenceEvaluator_sequence ReferenceEvaluator_;
  ConstantEvaluator_sequence ConstantEvaluator_;
  PiecewiseEvaluator_sequence PiecewiseEvaluator_;
  ParameterEvaluator_sequence ParameterEvaluator_;
  AggregateEvaluator_sequence AggregateEvaluator_;
  ::xsd::cxx::tree::one< name_type > name_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Fieldml_Type schema type.
 *
 * @nosubgrouping
 */
class Fieldml_Type: public ::FieldmlRdfTargetType
{
  public:
  /**
   * @name Region
   *
   * @brief Accessor and modifier functions for the %Region
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Region_Type Region_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Region_type, char > Region_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Region_type&
  Region () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Region_type&
  Region ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Region (const Region_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Region (::std::unique_ptr< Region_type > p);

  //@}

  /**
   * @name version
   *
   * @brief Accessor and modifier functions for the %version
   * optional attribute.
   */
  //@{

  /**
   * @brief Attribute type.
   */
  typedef ::xml_schema::string version_type;

  /**
   * @brief Attribute optional container type.
   */
  typedef ::xsd::cxx::tree::optional< version_type > version_optional;

  /**
   * @brief Attribute traits type.
   */
  typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

  /**
   * @brief Return a read-only (constant) reference to the attribute
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const version_optional&
  version () const;

  /**
   * @brief Return a read-write reference to the attribute container.
   *
   * @return A reference to the optional container.
   */
  version_optional&
  version ();

  /**
   * @brief Set the attribute value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the attribute.
   */
  void
  version (const version_type& x);

  /**
   * @brief Set the attribute value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the attribute.
   * Otherwise the attribute container is set the 'not present' state.
   */
  void
  version (const version_optional& x);

  /**
   * @brief Set the attribute value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  version (::std::unique_ptr< version_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Fieldml_Type (const Region_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Fieldml_Type (::std::unique_ptr< Region_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Fieldml_Type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Fieldml_Type (const Fieldml_Type& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Fieldml_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Fieldml_Type&
  operator= (const Fieldml_Type& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Fieldml_Type ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Region_type > Region_;
  version_optional version_;

  //@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %Fieldml document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& uri,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& uri,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& uri,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& id,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const FieldmlRdfTargetType&);

void
operator<< (::xercesc::DOMElement&, const FieldmlObject_Type&);

void
operator<< (::xercesc::DOMElement&, const ArrayDataSize_Type&);

void
operator<< (::xercesc::DOMAttr&, const ArrayDataSize_Type&);

void
operator<< (::xml_schema::list_stream&,
            const ArrayDataSize_Type&);

void
operator<< (::xercesc::DOMElement&, const ArrayDataOffset_Type&);

void
operator<< (::xercesc::DOMAttr&, const ArrayDataOffset_Type&);

void
operator<< (::xml_schema::list_stream&,
            const ArrayDataOffset_Type&);

void
operator<< (::xercesc::DOMElement&, const RawArraySize_Type&);

void
operator<< (::xercesc::DOMAttr&, const RawArraySize_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RawArraySize_Type&);

void
operator<< (::xercesc::DOMElement&, const ArrayDataSource_Type&);

void
operator<< (::xercesc::DOMElement&, const DataResourceHref_Type&);

void
operator<< (::xercesc::DOMElement&, const DataResourceString_Type&);

void
operator<< (::xercesc::DOMAttr&, const DataResourceString_Type&);

void
operator<< (::xml_schema::list_stream&,
            const DataResourceString_Type&);

void
operator<< (::xercesc::DOMElement&, const DataResourceDescription_Type&);

void
operator<< (::xercesc::DOMElement&, const DataResource_Type&);

void
operator<< (::xercesc::DOMElement&, const ImportTypeEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const ImportEvaluatorEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const Import_Type&);

void
operator<< (::xercesc::DOMElement&, const NumberedIndexEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const NumberedIndexEvaluatorList_Type&);

void
operator<< (::xercesc::DOMElement&, const BindMapEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const BindMapIndexEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const BindMapWithIndexes_Type&);

void
operator<< (::xercesc::DOMElement&, const BindMap_Type&);

void
operator<< (::xercesc::DOMElement&, const ComponentEvaluatorsEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const ComponentEvaluators_Type&);

void
operator<< (::xercesc::DOMElement&, const ShapeMap_Type&);

void
operator<< (::xercesc::DOMElement&, const ArgumentListEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const ArgumentList_Type&);

void
operator<< (::xercesc::DOMElement&, const EvaluatorListEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const IndexEvaluatorList_Type&);

void
operator<< (::xercesc::DOMElement&, const OrderedEvaluatorListEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const OrderedIndexEvaluatorList_Type&);

void
operator<< (::xercesc::DOMElement&, const MemberRange_Type&);

void
operator<< (::xercesc::DOMElement&, const MemberData_Type&);

void
operator<< (::xercesc::DOMElement&, const EnsembleMembers_Type&);

void
operator<< (::xercesc::DOMElement&, const BooleanType_Type&);

void
operator<< (::xercesc::DOMElement&, const EnsembleType_Type&);

void
operator<< (::xercesc::DOMElement&, const ContinuousComponent_Type&);

void
operator<< (::xercesc::DOMElement&, const ContinuousType_Type&);

void
operator<< (::xercesc::DOMElement&, const MeshType_Type&);

void
operator<< (::xercesc::DOMElement&, const FieldmlEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const ArgumentEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const ExternalEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const ConstantEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const ReferenceEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const EvaluatorMapEntry_Type&);

void
operator<< (::xercesc::DOMElement&, const EvaluatorMap_Type&);

void
operator<< (::xercesc::DOMElement&, const PiecewiseEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const DenseArrayData_Type&);

void
operator<< (::xercesc::DOMElement&, const DOKArrayData_Type&);

void
operator<< (::xercesc::DOMElement&, const ParameterEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const AggregateEvaluator_Type&);

void
operator<< (::xercesc::DOMElement&, const Region_Type&);

void
operator<< (::xercesc::DOMElement&, const Fieldml_Type&);

/**
 * @name Serialization functions for the %Fieldml document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
Fieldml (::std::ostream& os,
         const ::Fieldml_Type& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Fieldml (::std::ostream& os,
         const ::Fieldml_Type& x, 
         ::xml_schema::error_handler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Fieldml (::std::ostream& os,
         const ::Fieldml_Type& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
Fieldml (::xercesc::XMLFormatTarget& ft,
         const ::Fieldml_Type& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Fieldml (::xercesc::XMLFormatTarget& ft,
         const ::Fieldml_Type& x, 
         ::xml_schema::error_handler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Fieldml (::xercesc::XMLFormatTarget& ft,
         const ::Fieldml_Type& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void
Fieldml (::xercesc::DOMDocument& d,
         const ::Fieldml_Type& x,
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
Fieldml (const ::Fieldml_Type& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         ::xml_schema::flags f = 0);

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // FIELD_ML_0_5_HXX
