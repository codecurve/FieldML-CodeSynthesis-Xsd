// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "FieldML_0.5.hxx"

// FieldmlRdfTargetType
// 

const FieldmlRdfTargetType::id_optional& FieldmlRdfTargetType::
id () const
{
  return this->id_;
}

FieldmlRdfTargetType::id_optional& FieldmlRdfTargetType::
id ()
{
  return this->id_;
}

void FieldmlRdfTargetType::
id (const id_type& x)
{
  this->id_.set (x);
}

void FieldmlRdfTargetType::
id (const id_optional& x)
{
  this->id_ = x;
}

void FieldmlRdfTargetType::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// FieldmlObject_Type
// 

const FieldmlObject_Type::name_type& FieldmlObject_Type::
name () const
{
  return this->name_.get ();
}

FieldmlObject_Type::name_type& FieldmlObject_Type::
name ()
{
  return this->name_.get ();
}

void FieldmlObject_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void FieldmlObject_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// ArrayDataSize_Type
// 


// ArrayDataOffset_Type
// 


// RawArraySize_Type
// 


// ArrayDataSource_Type
// 

const ArrayDataSource_Type::ArrayDataSize_sequence& ArrayDataSource_Type::
ArrayDataSize () const
{
  return this->ArrayDataSize_;
}

ArrayDataSource_Type::ArrayDataSize_sequence& ArrayDataSource_Type::
ArrayDataSize ()
{
  return this->ArrayDataSize_;
}

void ArrayDataSource_Type::
ArrayDataSize (const ArrayDataSize_sequence& s)
{
  this->ArrayDataSize_ = s;
}

const ArrayDataSource_Type::ArrayDataOffset_sequence& ArrayDataSource_Type::
ArrayDataOffset () const
{
  return this->ArrayDataOffset_;
}

ArrayDataSource_Type::ArrayDataOffset_sequence& ArrayDataSource_Type::
ArrayDataOffset ()
{
  return this->ArrayDataOffset_;
}

void ArrayDataSource_Type::
ArrayDataOffset (const ArrayDataOffset_sequence& s)
{
  this->ArrayDataOffset_ = s;
}

const ArrayDataSource_Type::RawArraySize_sequence& ArrayDataSource_Type::
RawArraySize () const
{
  return this->RawArraySize_;
}

ArrayDataSource_Type::RawArraySize_sequence& ArrayDataSource_Type::
RawArraySize ()
{
  return this->RawArraySize_;
}

void ArrayDataSource_Type::
RawArraySize (const RawArraySize_sequence& s)
{
  this->RawArraySize_ = s;
}

const ArrayDataSource_Type::name_type& ArrayDataSource_Type::
name () const
{
  return this->name_.get ();
}

ArrayDataSource_Type::name_type& ArrayDataSource_Type::
name ()
{
  return this->name_.get ();
}

void ArrayDataSource_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void ArrayDataSource_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const ArrayDataSource_Type::location_type& ArrayDataSource_Type::
location () const
{
  return this->location_.get ();
}

ArrayDataSource_Type::location_type& ArrayDataSource_Type::
location ()
{
  return this->location_.get ();
}

void ArrayDataSource_Type::
location (const location_type& x)
{
  this->location_.set (x);
}

void ArrayDataSource_Type::
location (::std::unique_ptr< location_type > x)
{
  this->location_.set (std::move (x));
}

const ArrayDataSource_Type::rank_type& ArrayDataSource_Type::
rank () const
{
  return this->rank_.get ();
}

ArrayDataSource_Type::rank_type& ArrayDataSource_Type::
rank ()
{
  return this->rank_.get ();
}

void ArrayDataSource_Type::
rank (const rank_type& x)
{
  this->rank_.set (x);
}


// DataResourceHref_Type
// 

const DataResourceHref_Type::href_type& DataResourceHref_Type::
href () const
{
  return this->href_.get ();
}

DataResourceHref_Type::href_type& DataResourceHref_Type::
href ()
{
  return this->href_.get ();
}

void DataResourceHref_Type::
href (const href_type& x)
{
  this->href_.set (x);
}

void DataResourceHref_Type::
href (::std::unique_ptr< href_type > x)
{
  this->href_.set (std::move (x));
}

const DataResourceHref_Type::format_type& DataResourceHref_Type::
format () const
{
  return this->format_.get ();
}

DataResourceHref_Type::format_type& DataResourceHref_Type::
format ()
{
  return this->format_.get ();
}

void DataResourceHref_Type::
format (const format_type& x)
{
  this->format_.set (x);
}

void DataResourceHref_Type::
format (::std::unique_ptr< format_type > x)
{
  this->format_.set (std::move (x));
}


// DataResourceString_Type
// 


// DataResourceDescription_Type
// 

const DataResourceDescription_Type::DataResourceHref_optional& DataResourceDescription_Type::
DataResourceHref () const
{
  return this->DataResourceHref_;
}

DataResourceDescription_Type::DataResourceHref_optional& DataResourceDescription_Type::
DataResourceHref ()
{
  return this->DataResourceHref_;
}

void DataResourceDescription_Type::
DataResourceHref (const DataResourceHref_type& x)
{
  this->DataResourceHref_.set (x);
}

void DataResourceDescription_Type::
DataResourceHref (const DataResourceHref_optional& x)
{
  this->DataResourceHref_ = x;
}

void DataResourceDescription_Type::
DataResourceHref (::std::unique_ptr< DataResourceHref_type > x)
{
  this->DataResourceHref_.set (std::move (x));
}

const DataResourceDescription_Type::DataResourceString_optional& DataResourceDescription_Type::
DataResourceString () const
{
  return this->DataResourceString_;
}

DataResourceDescription_Type::DataResourceString_optional& DataResourceDescription_Type::
DataResourceString ()
{
  return this->DataResourceString_;
}

void DataResourceDescription_Type::
DataResourceString (const DataResourceString_type& x)
{
  this->DataResourceString_.set (x);
}

void DataResourceDescription_Type::
DataResourceString (const DataResourceString_optional& x)
{
  this->DataResourceString_ = x;
}

void DataResourceDescription_Type::
DataResourceString (::std::unique_ptr< DataResourceString_type > x)
{
  this->DataResourceString_.set (std::move (x));
}


// DataResource_Type
// 

const DataResource_Type::DataResourceDescription_sequence& DataResource_Type::
DataResourceDescription () const
{
  return this->DataResourceDescription_;
}

DataResource_Type::DataResourceDescription_sequence& DataResource_Type::
DataResourceDescription ()
{
  return this->DataResourceDescription_;
}

void DataResource_Type::
DataResourceDescription (const DataResourceDescription_sequence& s)
{
  this->DataResourceDescription_ = s;
}

const DataResource_Type::ArrayDataSource_sequence& DataResource_Type::
ArrayDataSource () const
{
  return this->ArrayDataSource_;
}

DataResource_Type::ArrayDataSource_sequence& DataResource_Type::
ArrayDataSource ()
{
  return this->ArrayDataSource_;
}

void DataResource_Type::
ArrayDataSource (const ArrayDataSource_sequence& s)
{
  this->ArrayDataSource_ = s;
}

const DataResource_Type::name_type& DataResource_Type::
name () const
{
  return this->name_.get ();
}

DataResource_Type::name_type& DataResource_Type::
name ()
{
  return this->name_.get ();
}

void DataResource_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void DataResource_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// ImportTypeEntry_Type
// 

const ImportTypeEntry_Type::localName_type& ImportTypeEntry_Type::
localName () const
{
  return this->localName_.get ();
}

ImportTypeEntry_Type::localName_type& ImportTypeEntry_Type::
localName ()
{
  return this->localName_.get ();
}

void ImportTypeEntry_Type::
localName (const localName_type& x)
{
  this->localName_.set (x);
}

void ImportTypeEntry_Type::
localName (::std::unique_ptr< localName_type > x)
{
  this->localName_.set (std::move (x));
}

const ImportTypeEntry_Type::remoteName_type& ImportTypeEntry_Type::
remoteName () const
{
  return this->remoteName_.get ();
}

ImportTypeEntry_Type::remoteName_type& ImportTypeEntry_Type::
remoteName ()
{
  return this->remoteName_.get ();
}

void ImportTypeEntry_Type::
remoteName (const remoteName_type& x)
{
  this->remoteName_.set (x);
}

void ImportTypeEntry_Type::
remoteName (::std::unique_ptr< remoteName_type > x)
{
  this->remoteName_.set (std::move (x));
}


// ImportEvaluatorEntry_Type
// 

const ImportEvaluatorEntry_Type::localName_type& ImportEvaluatorEntry_Type::
localName () const
{
  return this->localName_.get ();
}

ImportEvaluatorEntry_Type::localName_type& ImportEvaluatorEntry_Type::
localName ()
{
  return this->localName_.get ();
}

void ImportEvaluatorEntry_Type::
localName (const localName_type& x)
{
  this->localName_.set (x);
}

void ImportEvaluatorEntry_Type::
localName (::std::unique_ptr< localName_type > x)
{
  this->localName_.set (std::move (x));
}

const ImportEvaluatorEntry_Type::remoteName_type& ImportEvaluatorEntry_Type::
remoteName () const
{
  return this->remoteName_.get ();
}

ImportEvaluatorEntry_Type::remoteName_type& ImportEvaluatorEntry_Type::
remoteName ()
{
  return this->remoteName_.get ();
}

void ImportEvaluatorEntry_Type::
remoteName (const remoteName_type& x)
{
  this->remoteName_.set (x);
}

void ImportEvaluatorEntry_Type::
remoteName (::std::unique_ptr< remoteName_type > x)
{
  this->remoteName_.set (std::move (x));
}


// Import_Type
// 

const Import_Type::ImportType_sequence& Import_Type::
ImportType () const
{
  return this->ImportType_;
}

Import_Type::ImportType_sequence& Import_Type::
ImportType ()
{
  return this->ImportType_;
}

void Import_Type::
ImportType (const ImportType_sequence& s)
{
  this->ImportType_ = s;
}

const Import_Type::ImportEvaluator_sequence& Import_Type::
ImportEvaluator () const
{
  return this->ImportEvaluator_;
}

Import_Type::ImportEvaluator_sequence& Import_Type::
ImportEvaluator ()
{
  return this->ImportEvaluator_;
}

void Import_Type::
ImportEvaluator (const ImportEvaluator_sequence& s)
{
  this->ImportEvaluator_ = s;
}

const Import_Type::href_type& Import_Type::
href () const
{
  return this->href_.get ();
}

Import_Type::href_type& Import_Type::
href ()
{
  return this->href_.get ();
}

void Import_Type::
href (const href_type& x)
{
  this->href_.set (x);
}

void Import_Type::
href (::std::unique_ptr< href_type > x)
{
  this->href_.set (std::move (x));
}

const Import_Type::region_type& Import_Type::
region () const
{
  return this->region_.get ();
}

Import_Type::region_type& Import_Type::
region ()
{
  return this->region_.get ();
}

void Import_Type::
region (const region_type& x)
{
  this->region_.set (x);
}

void Import_Type::
region (::std::unique_ptr< region_type > x)
{
  this->region_.set (std::move (x));
}


// NumberedIndexEvaluator_Type
// 

const NumberedIndexEvaluator_Type::evaluator_type& NumberedIndexEvaluator_Type::
evaluator () const
{
  return this->evaluator_.get ();
}

NumberedIndexEvaluator_Type::evaluator_type& NumberedIndexEvaluator_Type::
evaluator ()
{
  return this->evaluator_.get ();
}

void NumberedIndexEvaluator_Type::
evaluator (const evaluator_type& x)
{
  this->evaluator_.set (x);
}

void NumberedIndexEvaluator_Type::
evaluator (::std::unique_ptr< evaluator_type > x)
{
  this->evaluator_.set (std::move (x));
}

const NumberedIndexEvaluator_Type::indexNumber_type& NumberedIndexEvaluator_Type::
indexNumber () const
{
  return this->indexNumber_.get ();
}

NumberedIndexEvaluator_Type::indexNumber_type& NumberedIndexEvaluator_Type::
indexNumber ()
{
  return this->indexNumber_.get ();
}

void NumberedIndexEvaluator_Type::
indexNumber (const indexNumber_type& x)
{
  this->indexNumber_.set (x);
}


// NumberedIndexEvaluatorList_Type
// 

const NumberedIndexEvaluatorList_Type::IndexEvaluator_sequence& NumberedIndexEvaluatorList_Type::
IndexEvaluator () const
{
  return this->IndexEvaluator_;
}

NumberedIndexEvaluatorList_Type::IndexEvaluator_sequence& NumberedIndexEvaluatorList_Type::
IndexEvaluator ()
{
  return this->IndexEvaluator_;
}

void NumberedIndexEvaluatorList_Type::
IndexEvaluator (const IndexEvaluator_sequence& s)
{
  this->IndexEvaluator_ = s;
}


// BindMapEntry_Type
// 

const BindMapEntry_Type::argument_type& BindMapEntry_Type::
argument () const
{
  return this->argument_.get ();
}

BindMapEntry_Type::argument_type& BindMapEntry_Type::
argument ()
{
  return this->argument_.get ();
}

void BindMapEntry_Type::
argument (const argument_type& x)
{
  this->argument_.set (x);
}

void BindMapEntry_Type::
argument (::std::unique_ptr< argument_type > x)
{
  this->argument_.set (std::move (x));
}

const BindMapEntry_Type::source_type& BindMapEntry_Type::
source () const
{
  return this->source_.get ();
}

BindMapEntry_Type::source_type& BindMapEntry_Type::
source ()
{
  return this->source_.get ();
}

void BindMapEntry_Type::
source (const source_type& x)
{
  this->source_.set (x);
}

void BindMapEntry_Type::
source (::std::unique_ptr< source_type > x)
{
  this->source_.set (std::move (x));
}


// BindMapIndexEntry_Type
// 

const BindMapIndexEntry_Type::argument_type& BindMapIndexEntry_Type::
argument () const
{
  return this->argument_.get ();
}

BindMapIndexEntry_Type::argument_type& BindMapIndexEntry_Type::
argument ()
{
  return this->argument_.get ();
}

void BindMapIndexEntry_Type::
argument (const argument_type& x)
{
  this->argument_.set (x);
}

void BindMapIndexEntry_Type::
argument (::std::unique_ptr< argument_type > x)
{
  this->argument_.set (std::move (x));
}

const BindMapIndexEntry_Type::indexNumber_type& BindMapIndexEntry_Type::
indexNumber () const
{
  return this->indexNumber_.get ();
}

BindMapIndexEntry_Type::indexNumber_type& BindMapIndexEntry_Type::
indexNumber ()
{
  return this->indexNumber_.get ();
}

void BindMapIndexEntry_Type::
indexNumber (const indexNumber_type& x)
{
  this->indexNumber_.set (x);
}


// BindMapWithIndexes_Type
// 

const BindMapWithIndexes_Type::BindIndex_sequence& BindMapWithIndexes_Type::
BindIndex () const
{
  return this->BindIndex_;
}

BindMapWithIndexes_Type::BindIndex_sequence& BindMapWithIndexes_Type::
BindIndex ()
{
  return this->BindIndex_;
}

void BindMapWithIndexes_Type::
BindIndex (const BindIndex_sequence& s)
{
  this->BindIndex_ = s;
}

const BindMapWithIndexes_Type::Bind_sequence& BindMapWithIndexes_Type::
Bind () const
{
  return this->Bind_;
}

BindMapWithIndexes_Type::Bind_sequence& BindMapWithIndexes_Type::
Bind ()
{
  return this->Bind_;
}

void BindMapWithIndexes_Type::
Bind (const Bind_sequence& s)
{
  this->Bind_ = s;
}


// BindMap_Type
// 

const BindMap_Type::Bind_sequence& BindMap_Type::
Bind () const
{
  return this->Bind_;
}

BindMap_Type::Bind_sequence& BindMap_Type::
Bind ()
{
  return this->Bind_;
}

void BindMap_Type::
Bind (const Bind_sequence& s)
{
  this->Bind_ = s;
}


// ComponentEvaluatorsEntry_Type
// 

const ComponentEvaluatorsEntry_Type::component_type& ComponentEvaluatorsEntry_Type::
component () const
{
  return this->component_.get ();
}

ComponentEvaluatorsEntry_Type::component_type& ComponentEvaluatorsEntry_Type::
component ()
{
  return this->component_.get ();
}

void ComponentEvaluatorsEntry_Type::
component (const component_type& x)
{
  this->component_.set (x);
}

const ComponentEvaluatorsEntry_Type::evaluator_type& ComponentEvaluatorsEntry_Type::
evaluator () const
{
  return this->evaluator_.get ();
}

ComponentEvaluatorsEntry_Type::evaluator_type& ComponentEvaluatorsEntry_Type::
evaluator ()
{
  return this->evaluator_.get ();
}

void ComponentEvaluatorsEntry_Type::
evaluator (const evaluator_type& x)
{
  this->evaluator_.set (x);
}

void ComponentEvaluatorsEntry_Type::
evaluator (::std::unique_ptr< evaluator_type > x)
{
  this->evaluator_.set (std::move (x));
}


// ComponentEvaluators_Type
// 

const ComponentEvaluators_Type::ComponentEvaluator_sequence& ComponentEvaluators_Type::
ComponentEvaluator () const
{
  return this->ComponentEvaluator_;
}

ComponentEvaluators_Type::ComponentEvaluator_sequence& ComponentEvaluators_Type::
ComponentEvaluator ()
{
  return this->ComponentEvaluator_;
}

void ComponentEvaluators_Type::
ComponentEvaluator (const ComponentEvaluator_sequence& s)
{
  this->ComponentEvaluator_ = s;
}

const ComponentEvaluators_Type::default_optional& ComponentEvaluators_Type::
default_ () const
{
  return this->default__;
}

ComponentEvaluators_Type::default_optional& ComponentEvaluators_Type::
default_ ()
{
  return this->default__;
}

void ComponentEvaluators_Type::
default_ (const default_type& x)
{
  this->default__.set (x);
}

void ComponentEvaluators_Type::
default_ (const default_optional& x)
{
  this->default__ = x;
}

void ComponentEvaluators_Type::
default_ (::std::unique_ptr< default_type > x)
{
  this->default__.set (std::move (x));
}


// ShapeMap_Type
// 

const ShapeMap_Type::evaluator_type& ShapeMap_Type::
evaluator () const
{
  return this->evaluator_.get ();
}

ShapeMap_Type::evaluator_type& ShapeMap_Type::
evaluator ()
{
  return this->evaluator_.get ();
}

void ShapeMap_Type::
evaluator (const evaluator_type& x)
{
  this->evaluator_.set (x);
}

void ShapeMap_Type::
evaluator (::std::unique_ptr< evaluator_type > x)
{
  this->evaluator_.set (std::move (x));
}


// ArgumentListEntry_Type
// 

const ArgumentListEntry_Type::name_type& ArgumentListEntry_Type::
name () const
{
  return this->name_.get ();
}

ArgumentListEntry_Type::name_type& ArgumentListEntry_Type::
name ()
{
  return this->name_.get ();
}

void ArgumentListEntry_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void ArgumentListEntry_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// ArgumentList_Type
// 

const ArgumentList_Type::Argument_sequence& ArgumentList_Type::
Argument () const
{
  return this->Argument_;
}

ArgumentList_Type::Argument_sequence& ArgumentList_Type::
Argument ()
{
  return this->Argument_;
}

void ArgumentList_Type::
Argument (const Argument_sequence& s)
{
  this->Argument_ = s;
}


// EvaluatorListEntry_Type
// 

const EvaluatorListEntry_Type::evaluator_type& EvaluatorListEntry_Type::
evaluator () const
{
  return this->evaluator_.get ();
}

EvaluatorListEntry_Type::evaluator_type& EvaluatorListEntry_Type::
evaluator ()
{
  return this->evaluator_.get ();
}

void EvaluatorListEntry_Type::
evaluator (const evaluator_type& x)
{
  this->evaluator_.set (x);
}

void EvaluatorListEntry_Type::
evaluator (::std::unique_ptr< evaluator_type > x)
{
  this->evaluator_.set (std::move (x));
}


// IndexEvaluatorList_Type
// 

const IndexEvaluatorList_Type::IndexEvaluator_sequence& IndexEvaluatorList_Type::
IndexEvaluator () const
{
  return this->IndexEvaluator_;
}

IndexEvaluatorList_Type::IndexEvaluator_sequence& IndexEvaluatorList_Type::
IndexEvaluator ()
{
  return this->IndexEvaluator_;
}

void IndexEvaluatorList_Type::
IndexEvaluator (const IndexEvaluator_sequence& s)
{
  this->IndexEvaluator_ = s;
}


// OrderedEvaluatorListEntry_Type
// 

const OrderedEvaluatorListEntry_Type::evaluator_type& OrderedEvaluatorListEntry_Type::
evaluator () const
{
  return this->evaluator_.get ();
}

OrderedEvaluatorListEntry_Type::evaluator_type& OrderedEvaluatorListEntry_Type::
evaluator ()
{
  return this->evaluator_.get ();
}

void OrderedEvaluatorListEntry_Type::
evaluator (const evaluator_type& x)
{
  this->evaluator_.set (x);
}

void OrderedEvaluatorListEntry_Type::
evaluator (::std::unique_ptr< evaluator_type > x)
{
  this->evaluator_.set (std::move (x));
}

const OrderedEvaluatorListEntry_Type::order_optional& OrderedEvaluatorListEntry_Type::
order () const
{
  return this->order_;
}

OrderedEvaluatorListEntry_Type::order_optional& OrderedEvaluatorListEntry_Type::
order ()
{
  return this->order_;
}

void OrderedEvaluatorListEntry_Type::
order (const order_type& x)
{
  this->order_.set (x);
}

void OrderedEvaluatorListEntry_Type::
order (const order_optional& x)
{
  this->order_ = x;
}

void OrderedEvaluatorListEntry_Type::
order (::std::unique_ptr< order_type > x)
{
  this->order_.set (std::move (x));
}


// OrderedIndexEvaluatorList_Type
// 

const OrderedIndexEvaluatorList_Type::IndexEvaluator_sequence& OrderedIndexEvaluatorList_Type::
IndexEvaluator () const
{
  return this->IndexEvaluator_;
}

OrderedIndexEvaluatorList_Type::IndexEvaluator_sequence& OrderedIndexEvaluatorList_Type::
IndexEvaluator ()
{
  return this->IndexEvaluator_;
}

void OrderedIndexEvaluatorList_Type::
IndexEvaluator (const IndexEvaluator_sequence& s)
{
  this->IndexEvaluator_ = s;
}


// MemberRange_Type
// 

const MemberRange_Type::min_type& MemberRange_Type::
min () const
{
  return this->min_.get ();
}

MemberRange_Type::min_type& MemberRange_Type::
min ()
{
  return this->min_.get ();
}

void MemberRange_Type::
min (const min_type& x)
{
  this->min_.set (x);
}

const MemberRange_Type::max_type& MemberRange_Type::
max () const
{
  return this->max_.get ();
}

MemberRange_Type::max_type& MemberRange_Type::
max ()
{
  return this->max_.get ();
}

void MemberRange_Type::
max (const max_type& x)
{
  this->max_.set (x);
}

const MemberRange_Type::stride_optional& MemberRange_Type::
stride () const
{
  return this->stride_;
}

MemberRange_Type::stride_optional& MemberRange_Type::
stride ()
{
  return this->stride_;
}

void MemberRange_Type::
stride (const stride_type& x)
{
  this->stride_.set (x);
}

void MemberRange_Type::
stride (const stride_optional& x)
{
  this->stride_ = x;
}


// MemberData_Type
// 

const MemberData_Type::count_type& MemberData_Type::
count () const
{
  return this->count_.get ();
}

MemberData_Type::count_type& MemberData_Type::
count ()
{
  return this->count_.get ();
}

void MemberData_Type::
count (const count_type& x)
{
  this->count_.set (x);
}

const MemberData_Type::data_type& MemberData_Type::
data () const
{
  return this->data_.get ();
}

MemberData_Type::data_type& MemberData_Type::
data ()
{
  return this->data_.get ();
}

void MemberData_Type::
data (const data_type& x)
{
  this->data_.set (x);
}

void MemberData_Type::
data (::std::unique_ptr< data_type > x)
{
  this->data_.set (std::move (x));
}


// EnsembleMembers_Type
// 

const EnsembleMembers_Type::MemberListData_optional& EnsembleMembers_Type::
MemberListData () const
{
  return this->MemberListData_;
}

EnsembleMembers_Type::MemberListData_optional& EnsembleMembers_Type::
MemberListData ()
{
  return this->MemberListData_;
}

void EnsembleMembers_Type::
MemberListData (const MemberListData_type& x)
{
  this->MemberListData_.set (x);
}

void EnsembleMembers_Type::
MemberListData (const MemberListData_optional& x)
{
  this->MemberListData_ = x;
}

void EnsembleMembers_Type::
MemberListData (::std::unique_ptr< MemberListData_type > x)
{
  this->MemberListData_.set (std::move (x));
}

const EnsembleMembers_Type::MemberRangeData_optional& EnsembleMembers_Type::
MemberRangeData () const
{
  return this->MemberRangeData_;
}

EnsembleMembers_Type::MemberRangeData_optional& EnsembleMembers_Type::
MemberRangeData ()
{
  return this->MemberRangeData_;
}

void EnsembleMembers_Type::
MemberRangeData (const MemberRangeData_type& x)
{
  this->MemberRangeData_.set (x);
}

void EnsembleMembers_Type::
MemberRangeData (const MemberRangeData_optional& x)
{
  this->MemberRangeData_ = x;
}

void EnsembleMembers_Type::
MemberRangeData (::std::unique_ptr< MemberRangeData_type > x)
{
  this->MemberRangeData_.set (std::move (x));
}

const EnsembleMembers_Type::MemberStrideRangeData_optional& EnsembleMembers_Type::
MemberStrideRangeData () const
{
  return this->MemberStrideRangeData_;
}

EnsembleMembers_Type::MemberStrideRangeData_optional& EnsembleMembers_Type::
MemberStrideRangeData ()
{
  return this->MemberStrideRangeData_;
}

void EnsembleMembers_Type::
MemberStrideRangeData (const MemberStrideRangeData_type& x)
{
  this->MemberStrideRangeData_.set (x);
}

void EnsembleMembers_Type::
MemberStrideRangeData (const MemberStrideRangeData_optional& x)
{
  this->MemberStrideRangeData_ = x;
}

void EnsembleMembers_Type::
MemberStrideRangeData (::std::unique_ptr< MemberStrideRangeData_type > x)
{
  this->MemberStrideRangeData_.set (std::move (x));
}

const EnsembleMembers_Type::MemberRange_optional& EnsembleMembers_Type::
MemberRange () const
{
  return this->MemberRange_;
}

EnsembleMembers_Type::MemberRange_optional& EnsembleMembers_Type::
MemberRange ()
{
  return this->MemberRange_;
}

void EnsembleMembers_Type::
MemberRange (const MemberRange_type& x)
{
  this->MemberRange_.set (x);
}

void EnsembleMembers_Type::
MemberRange (const MemberRange_optional& x)
{
  this->MemberRange_ = x;
}

void EnsembleMembers_Type::
MemberRange (::std::unique_ptr< MemberRange_type > x)
{
  this->MemberRange_.set (std::move (x));
}


// BooleanType_Type
// 


// EnsembleType_Type
// 

const EnsembleType_Type::Members_type& EnsembleType_Type::
Members () const
{
  return this->Members_.get ();
}

EnsembleType_Type::Members_type& EnsembleType_Type::
Members ()
{
  return this->Members_.get ();
}

void EnsembleType_Type::
Members (const Members_type& x)
{
  this->Members_.set (x);
}

void EnsembleType_Type::
Members (::std::unique_ptr< Members_type > x)
{
  this->Members_.set (std::move (x));
}


// ContinuousComponent_Type
// 

const ContinuousComponent_Type::name_type& ContinuousComponent_Type::
name () const
{
  return this->name_.get ();
}

ContinuousComponent_Type::name_type& ContinuousComponent_Type::
name ()
{
  return this->name_.get ();
}

void ContinuousComponent_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void ContinuousComponent_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const ContinuousComponent_Type::count_type& ContinuousComponent_Type::
count () const
{
  return this->count_.get ();
}

ContinuousComponent_Type::count_type& ContinuousComponent_Type::
count ()
{
  return this->count_.get ();
}

void ContinuousComponent_Type::
count (const count_type& x)
{
  this->count_.set (x);
}


// ContinuousType_Type
// 

const ContinuousType_Type::Components_optional& ContinuousType_Type::
Components () const
{
  return this->Components_;
}

ContinuousType_Type::Components_optional& ContinuousType_Type::
Components ()
{
  return this->Components_;
}

void ContinuousType_Type::
Components (const Components_type& x)
{
  this->Components_.set (x);
}

void ContinuousType_Type::
Components (const Components_optional& x)
{
  this->Components_ = x;
}

void ContinuousType_Type::
Components (::std::unique_ptr< Components_type > x)
{
  this->Components_.set (std::move (x));
}


// MeshType_Type
// 

const MeshType_Type::Elements_type& MeshType_Type::
Elements () const
{
  return this->Elements_.get ();
}

MeshType_Type::Elements_type& MeshType_Type::
Elements ()
{
  return this->Elements_.get ();
}

void MeshType_Type::
Elements (const Elements_type& x)
{
  this->Elements_.set (x);
}

void MeshType_Type::
Elements (::std::unique_ptr< Elements_type > x)
{
  this->Elements_.set (std::move (x));
}

const MeshType_Type::Chart_type& MeshType_Type::
Chart () const
{
  return this->Chart_.get ();
}

MeshType_Type::Chart_type& MeshType_Type::
Chart ()
{
  return this->Chart_.get ();
}

void MeshType_Type::
Chart (const Chart_type& x)
{
  this->Chart_.set (x);
}

void MeshType_Type::
Chart (::std::unique_ptr< Chart_type > x)
{
  this->Chart_.set (std::move (x));
}

const MeshType_Type::Shapes_type& MeshType_Type::
Shapes () const
{
  return this->Shapes_.get ();
}

MeshType_Type::Shapes_type& MeshType_Type::
Shapes ()
{
  return this->Shapes_.get ();
}

void MeshType_Type::
Shapes (const Shapes_type& x)
{
  this->Shapes_.set (x);
}

void MeshType_Type::
Shapes (::std::unique_ptr< Shapes_type > x)
{
  this->Shapes_.set (std::move (x));
}


// FieldmlEvaluator_Type
// 

const FieldmlEvaluator_Type::Arguments_optional& FieldmlEvaluator_Type::
Arguments () const
{
  return this->Arguments_;
}

FieldmlEvaluator_Type::Arguments_optional& FieldmlEvaluator_Type::
Arguments ()
{
  return this->Arguments_;
}

void FieldmlEvaluator_Type::
Arguments (const Arguments_type& x)
{
  this->Arguments_.set (x);
}

void FieldmlEvaluator_Type::
Arguments (const Arguments_optional& x)
{
  this->Arguments_ = x;
}

void FieldmlEvaluator_Type::
Arguments (::std::unique_ptr< Arguments_type > x)
{
  this->Arguments_.set (std::move (x));
}

const FieldmlEvaluator_Type::valueType_type& FieldmlEvaluator_Type::
valueType () const
{
  return this->valueType_.get ();
}

FieldmlEvaluator_Type::valueType_type& FieldmlEvaluator_Type::
valueType ()
{
  return this->valueType_.get ();
}

void FieldmlEvaluator_Type::
valueType (const valueType_type& x)
{
  this->valueType_.set (x);
}

void FieldmlEvaluator_Type::
valueType (::std::unique_ptr< valueType_type > x)
{
  this->valueType_.set (std::move (x));
}


// ArgumentEvaluator_Type
// 


// ExternalEvaluator_Type
// 


// ConstantEvaluator_Type
// 

const ConstantEvaluator_Type::value_type& ConstantEvaluator_Type::
value () const
{
  return this->value_.get ();
}

ConstantEvaluator_Type::value_type& ConstantEvaluator_Type::
value ()
{
  return this->value_.get ();
}

void ConstantEvaluator_Type::
value (const value_type& x)
{
  this->value_.set (x);
}

void ConstantEvaluator_Type::
value (::std::unique_ptr< value_type > x)
{
  this->value_.set (std::move (x));
}

const ConstantEvaluator_Type::valueType_type& ConstantEvaluator_Type::
valueType () const
{
  return this->valueType_.get ();
}

ConstantEvaluator_Type::valueType_type& ConstantEvaluator_Type::
valueType ()
{
  return this->valueType_.get ();
}

void ConstantEvaluator_Type::
valueType (const valueType_type& x)
{
  this->valueType_.set (x);
}

void ConstantEvaluator_Type::
valueType (::std::unique_ptr< valueType_type > x)
{
  this->valueType_.set (std::move (x));
}


// ReferenceEvaluator_Type
// 

const ReferenceEvaluator_Type::Arguments_optional& ReferenceEvaluator_Type::
Arguments () const
{
  return this->Arguments_;
}

ReferenceEvaluator_Type::Arguments_optional& ReferenceEvaluator_Type::
Arguments ()
{
  return this->Arguments_;
}

void ReferenceEvaluator_Type::
Arguments (const Arguments_type& x)
{
  this->Arguments_.set (x);
}

void ReferenceEvaluator_Type::
Arguments (const Arguments_optional& x)
{
  this->Arguments_ = x;
}

void ReferenceEvaluator_Type::
Arguments (::std::unique_ptr< Arguments_type > x)
{
  this->Arguments_.set (std::move (x));
}

const ReferenceEvaluator_Type::Bindings_optional& ReferenceEvaluator_Type::
Bindings () const
{
  return this->Bindings_;
}

ReferenceEvaluator_Type::Bindings_optional& ReferenceEvaluator_Type::
Bindings ()
{
  return this->Bindings_;
}

void ReferenceEvaluator_Type::
Bindings (const Bindings_type& x)
{
  this->Bindings_.set (x);
}

void ReferenceEvaluator_Type::
Bindings (const Bindings_optional& x)
{
  this->Bindings_ = x;
}

void ReferenceEvaluator_Type::
Bindings (::std::unique_ptr< Bindings_type > x)
{
  this->Bindings_.set (std::move (x));
}

const ReferenceEvaluator_Type::valueType_optional& ReferenceEvaluator_Type::
valueType () const
{
  return this->valueType_;
}

ReferenceEvaluator_Type::valueType_optional& ReferenceEvaluator_Type::
valueType ()
{
  return this->valueType_;
}

void ReferenceEvaluator_Type::
valueType (const valueType_type& x)
{
  this->valueType_.set (x);
}

void ReferenceEvaluator_Type::
valueType (const valueType_optional& x)
{
  this->valueType_ = x;
}

void ReferenceEvaluator_Type::
valueType (::std::unique_ptr< valueType_type > x)
{
  this->valueType_.set (std::move (x));
}

const ReferenceEvaluator_Type::evaluator_type& ReferenceEvaluator_Type::
evaluator () const
{
  return this->evaluator_.get ();
}

ReferenceEvaluator_Type::evaluator_type& ReferenceEvaluator_Type::
evaluator ()
{
  return this->evaluator_.get ();
}

void ReferenceEvaluator_Type::
evaluator (const evaluator_type& x)
{
  this->evaluator_.set (x);
}

void ReferenceEvaluator_Type::
evaluator (::std::unique_ptr< evaluator_type > x)
{
  this->evaluator_.set (std::move (x));
}


// EvaluatorMapEntry_Type
// 

const EvaluatorMapEntry_Type::value_type& EvaluatorMapEntry_Type::
value () const
{
  return this->value_.get ();
}

EvaluatorMapEntry_Type::value_type& EvaluatorMapEntry_Type::
value ()
{
  return this->value_.get ();
}

void EvaluatorMapEntry_Type::
value (const value_type& x)
{
  this->value_.set (x);
}

const EvaluatorMapEntry_Type::evaluator_type& EvaluatorMapEntry_Type::
evaluator () const
{
  return this->evaluator_.get ();
}

EvaluatorMapEntry_Type::evaluator_type& EvaluatorMapEntry_Type::
evaluator ()
{
  return this->evaluator_.get ();
}

void EvaluatorMapEntry_Type::
evaluator (const evaluator_type& x)
{
  this->evaluator_.set (x);
}

void EvaluatorMapEntry_Type::
evaluator (::std::unique_ptr< evaluator_type > x)
{
  this->evaluator_.set (std::move (x));
}


// EvaluatorMap_Type
// 

const EvaluatorMap_Type::EvaluatorMapEntry_sequence& EvaluatorMap_Type::
EvaluatorMapEntry () const
{
  return this->EvaluatorMapEntry_;
}

EvaluatorMap_Type::EvaluatorMapEntry_sequence& EvaluatorMap_Type::
EvaluatorMapEntry ()
{
  return this->EvaluatorMapEntry_;
}

void EvaluatorMap_Type::
EvaluatorMapEntry (const EvaluatorMapEntry_sequence& s)
{
  this->EvaluatorMapEntry_ = s;
}

const EvaluatorMap_Type::default_optional& EvaluatorMap_Type::
default_ () const
{
  return this->default__;
}

EvaluatorMap_Type::default_optional& EvaluatorMap_Type::
default_ ()
{
  return this->default__;
}

void EvaluatorMap_Type::
default_ (const default_type& x)
{
  this->default__.set (x);
}

void EvaluatorMap_Type::
default_ (const default_optional& x)
{
  this->default__ = x;
}

void EvaluatorMap_Type::
default_ (::std::unique_ptr< default_type > x)
{
  this->default__.set (std::move (x));
}


// PiecewiseEvaluator_Type
// 

const PiecewiseEvaluator_Type::Bindings_optional& PiecewiseEvaluator_Type::
Bindings () const
{
  return this->Bindings_;
}

PiecewiseEvaluator_Type::Bindings_optional& PiecewiseEvaluator_Type::
Bindings ()
{
  return this->Bindings_;
}

void PiecewiseEvaluator_Type::
Bindings (const Bindings_type& x)
{
  this->Bindings_.set (x);
}

void PiecewiseEvaluator_Type::
Bindings (const Bindings_optional& x)
{
  this->Bindings_ = x;
}

void PiecewiseEvaluator_Type::
Bindings (::std::unique_ptr< Bindings_type > x)
{
  this->Bindings_.set (std::move (x));
}

const PiecewiseEvaluator_Type::IndexEvaluators_optional& PiecewiseEvaluator_Type::
IndexEvaluators () const
{
  return this->IndexEvaluators_;
}

PiecewiseEvaluator_Type::IndexEvaluators_optional& PiecewiseEvaluator_Type::
IndexEvaluators ()
{
  return this->IndexEvaluators_;
}

void PiecewiseEvaluator_Type::
IndexEvaluators (const IndexEvaluators_type& x)
{
  this->IndexEvaluators_.set (x);
}

void PiecewiseEvaluator_Type::
IndexEvaluators (const IndexEvaluators_optional& x)
{
  this->IndexEvaluators_ = x;
}

void PiecewiseEvaluator_Type::
IndexEvaluators (::std::unique_ptr< IndexEvaluators_type > x)
{
  this->IndexEvaluators_.set (std::move (x));
}

const PiecewiseEvaluator_Type::EvaluatorMap_type& PiecewiseEvaluator_Type::
EvaluatorMap () const
{
  return this->EvaluatorMap_.get ();
}

PiecewiseEvaluator_Type::EvaluatorMap_type& PiecewiseEvaluator_Type::
EvaluatorMap ()
{
  return this->EvaluatorMap_.get ();
}

void PiecewiseEvaluator_Type::
EvaluatorMap (const EvaluatorMap_type& x)
{
  this->EvaluatorMap_.set (x);
}

void PiecewiseEvaluator_Type::
EvaluatorMap (::std::unique_ptr< EvaluatorMap_type > x)
{
  this->EvaluatorMap_.set (std::move (x));
}


// DenseArrayData_Type
// 

const DenseArrayData_Type::DenseIndexes_optional& DenseArrayData_Type::
DenseIndexes () const
{
  return this->DenseIndexes_;
}

DenseArrayData_Type::DenseIndexes_optional& DenseArrayData_Type::
DenseIndexes ()
{
  return this->DenseIndexes_;
}

void DenseArrayData_Type::
DenseIndexes (const DenseIndexes_type& x)
{
  this->DenseIndexes_.set (x);
}

void DenseArrayData_Type::
DenseIndexes (const DenseIndexes_optional& x)
{
  this->DenseIndexes_ = x;
}

void DenseArrayData_Type::
DenseIndexes (::std::unique_ptr< DenseIndexes_type > x)
{
  this->DenseIndexes_.set (std::move (x));
}

const DenseArrayData_Type::data_type& DenseArrayData_Type::
data () const
{
  return this->data_.get ();
}

DenseArrayData_Type::data_type& DenseArrayData_Type::
data ()
{
  return this->data_.get ();
}

void DenseArrayData_Type::
data (const data_type& x)
{
  this->data_.set (x);
}

void DenseArrayData_Type::
data (::std::unique_ptr< data_type > x)
{
  this->data_.set (std::move (x));
}


// DOKArrayData_Type
// 

const DOKArrayData_Type::DenseIndexes_optional& DOKArrayData_Type::
DenseIndexes () const
{
  return this->DenseIndexes_;
}

DOKArrayData_Type::DenseIndexes_optional& DOKArrayData_Type::
DenseIndexes ()
{
  return this->DenseIndexes_;
}

void DOKArrayData_Type::
DenseIndexes (const DenseIndexes_type& x)
{
  this->DenseIndexes_.set (x);
}

void DOKArrayData_Type::
DenseIndexes (const DenseIndexes_optional& x)
{
  this->DenseIndexes_ = x;
}

void DOKArrayData_Type::
DenseIndexes (::std::unique_ptr< DenseIndexes_type > x)
{
  this->DenseIndexes_.set (std::move (x));
}

const DOKArrayData_Type::SparseIndexes_type& DOKArrayData_Type::
SparseIndexes () const
{
  return this->SparseIndexes_.get ();
}

DOKArrayData_Type::SparseIndexes_type& DOKArrayData_Type::
SparseIndexes ()
{
  return this->SparseIndexes_.get ();
}

void DOKArrayData_Type::
SparseIndexes (const SparseIndexes_type& x)
{
  this->SparseIndexes_.set (x);
}

void DOKArrayData_Type::
SparseIndexes (::std::unique_ptr< SparseIndexes_type > x)
{
  this->SparseIndexes_.set (std::move (x));
}

const DOKArrayData_Type::keyData_type& DOKArrayData_Type::
keyData () const
{
  return this->keyData_.get ();
}

DOKArrayData_Type::keyData_type& DOKArrayData_Type::
keyData ()
{
  return this->keyData_.get ();
}

void DOKArrayData_Type::
keyData (const keyData_type& x)
{
  this->keyData_.set (x);
}

void DOKArrayData_Type::
keyData (::std::unique_ptr< keyData_type > x)
{
  this->keyData_.set (std::move (x));
}

const DOKArrayData_Type::valueData_type& DOKArrayData_Type::
valueData () const
{
  return this->valueData_.get ();
}

DOKArrayData_Type::valueData_type& DOKArrayData_Type::
valueData ()
{
  return this->valueData_.get ();
}

void DOKArrayData_Type::
valueData (const valueData_type& x)
{
  this->valueData_.set (x);
}

void DOKArrayData_Type::
valueData (::std::unique_ptr< valueData_type > x)
{
  this->valueData_.set (std::move (x));
}


// ParameterEvaluator_Type
// 

const ParameterEvaluator_Type::DenseArrayData_optional& ParameterEvaluator_Type::
DenseArrayData () const
{
  return this->DenseArrayData_;
}

ParameterEvaluator_Type::DenseArrayData_optional& ParameterEvaluator_Type::
DenseArrayData ()
{
  return this->DenseArrayData_;
}

void ParameterEvaluator_Type::
DenseArrayData (const DenseArrayData_type& x)
{
  this->DenseArrayData_.set (x);
}

void ParameterEvaluator_Type::
DenseArrayData (const DenseArrayData_optional& x)
{
  this->DenseArrayData_ = x;
}

void ParameterEvaluator_Type::
DenseArrayData (::std::unique_ptr< DenseArrayData_type > x)
{
  this->DenseArrayData_.set (std::move (x));
}

const ParameterEvaluator_Type::DOKArrayData_optional& ParameterEvaluator_Type::
DOKArrayData () const
{
  return this->DOKArrayData_;
}

ParameterEvaluator_Type::DOKArrayData_optional& ParameterEvaluator_Type::
DOKArrayData ()
{
  return this->DOKArrayData_;
}

void ParameterEvaluator_Type::
DOKArrayData (const DOKArrayData_type& x)
{
  this->DOKArrayData_.set (x);
}

void ParameterEvaluator_Type::
DOKArrayData (const DOKArrayData_optional& x)
{
  this->DOKArrayData_ = x;
}

void ParameterEvaluator_Type::
DOKArrayData (::std::unique_ptr< DOKArrayData_type > x)
{
  this->DOKArrayData_.set (std::move (x));
}


// AggregateEvaluator_Type
// 

const AggregateEvaluator_Type::Bindings_optional& AggregateEvaluator_Type::
Bindings () const
{
  return this->Bindings_;
}

AggregateEvaluator_Type::Bindings_optional& AggregateEvaluator_Type::
Bindings ()
{
  return this->Bindings_;
}

void AggregateEvaluator_Type::
Bindings (const Bindings_type& x)
{
  this->Bindings_.set (x);
}

void AggregateEvaluator_Type::
Bindings (const Bindings_optional& x)
{
  this->Bindings_ = x;
}

void AggregateEvaluator_Type::
Bindings (::std::unique_ptr< Bindings_type > x)
{
  this->Bindings_.set (std::move (x));
}

const AggregateEvaluator_Type::ComponentEvaluators_type& AggregateEvaluator_Type::
ComponentEvaluators () const
{
  return this->ComponentEvaluators_.get ();
}

AggregateEvaluator_Type::ComponentEvaluators_type& AggregateEvaluator_Type::
ComponentEvaluators ()
{
  return this->ComponentEvaluators_.get ();
}

void AggregateEvaluator_Type::
ComponentEvaluators (const ComponentEvaluators_type& x)
{
  this->ComponentEvaluators_.set (x);
}

void AggregateEvaluator_Type::
ComponentEvaluators (::std::unique_ptr< ComponentEvaluators_type > x)
{
  this->ComponentEvaluators_.set (std::move (x));
}


// Region_Type
// 

const Region_Type::Import_sequence& Region_Type::
Import () const
{
  return this->Import_;
}

Region_Type::Import_sequence& Region_Type::
Import ()
{
  return this->Import_;
}

void Region_Type::
Import (const Import_sequence& s)
{
  this->Import_ = s;
}

const Region_Type::DataResource_sequence& Region_Type::
DataResource () const
{
  return this->DataResource_;
}

Region_Type::DataResource_sequence& Region_Type::
DataResource ()
{
  return this->DataResource_;
}

void Region_Type::
DataResource (const DataResource_sequence& s)
{
  this->DataResource_ = s;
}

const Region_Type::BooleanType_sequence& Region_Type::
BooleanType () const
{
  return this->BooleanType_;
}

Region_Type::BooleanType_sequence& Region_Type::
BooleanType ()
{
  return this->BooleanType_;
}

void Region_Type::
BooleanType (const BooleanType_sequence& s)
{
  this->BooleanType_ = s;
}

const Region_Type::EnsembleType_sequence& Region_Type::
EnsembleType () const
{
  return this->EnsembleType_;
}

Region_Type::EnsembleType_sequence& Region_Type::
EnsembleType ()
{
  return this->EnsembleType_;
}

void Region_Type::
EnsembleType (const EnsembleType_sequence& s)
{
  this->EnsembleType_ = s;
}

const Region_Type::ContinuousType_sequence& Region_Type::
ContinuousType () const
{
  return this->ContinuousType_;
}

Region_Type::ContinuousType_sequence& Region_Type::
ContinuousType ()
{
  return this->ContinuousType_;
}

void Region_Type::
ContinuousType (const ContinuousType_sequence& s)
{
  this->ContinuousType_ = s;
}

const Region_Type::MeshType_sequence& Region_Type::
MeshType () const
{
  return this->MeshType_;
}

Region_Type::MeshType_sequence& Region_Type::
MeshType ()
{
  return this->MeshType_;
}

void Region_Type::
MeshType (const MeshType_sequence& s)
{
  this->MeshType_ = s;
}

const Region_Type::ArgumentEvaluator_sequence& Region_Type::
ArgumentEvaluator () const
{
  return this->ArgumentEvaluator_;
}

Region_Type::ArgumentEvaluator_sequence& Region_Type::
ArgumentEvaluator ()
{
  return this->ArgumentEvaluator_;
}

void Region_Type::
ArgumentEvaluator (const ArgumentEvaluator_sequence& s)
{
  this->ArgumentEvaluator_ = s;
}

const Region_Type::ExternalEvaluator_sequence& Region_Type::
ExternalEvaluator () const
{
  return this->ExternalEvaluator_;
}

Region_Type::ExternalEvaluator_sequence& Region_Type::
ExternalEvaluator ()
{
  return this->ExternalEvaluator_;
}

void Region_Type::
ExternalEvaluator (const ExternalEvaluator_sequence& s)
{
  this->ExternalEvaluator_ = s;
}

const Region_Type::ReferenceEvaluator_sequence& Region_Type::
ReferenceEvaluator () const
{
  return this->ReferenceEvaluator_;
}

Region_Type::ReferenceEvaluator_sequence& Region_Type::
ReferenceEvaluator ()
{
  return this->ReferenceEvaluator_;
}

void Region_Type::
ReferenceEvaluator (const ReferenceEvaluator_sequence& s)
{
  this->ReferenceEvaluator_ = s;
}

const Region_Type::ConstantEvaluator_sequence& Region_Type::
ConstantEvaluator () const
{
  return this->ConstantEvaluator_;
}

Region_Type::ConstantEvaluator_sequence& Region_Type::
ConstantEvaluator ()
{
  return this->ConstantEvaluator_;
}

void Region_Type::
ConstantEvaluator (const ConstantEvaluator_sequence& s)
{
  this->ConstantEvaluator_ = s;
}

const Region_Type::PiecewiseEvaluator_sequence& Region_Type::
PiecewiseEvaluator () const
{
  return this->PiecewiseEvaluator_;
}

Region_Type::PiecewiseEvaluator_sequence& Region_Type::
PiecewiseEvaluator ()
{
  return this->PiecewiseEvaluator_;
}

void Region_Type::
PiecewiseEvaluator (const PiecewiseEvaluator_sequence& s)
{
  this->PiecewiseEvaluator_ = s;
}

const Region_Type::ParameterEvaluator_sequence& Region_Type::
ParameterEvaluator () const
{
  return this->ParameterEvaluator_;
}

Region_Type::ParameterEvaluator_sequence& Region_Type::
ParameterEvaluator ()
{
  return this->ParameterEvaluator_;
}

void Region_Type::
ParameterEvaluator (const ParameterEvaluator_sequence& s)
{
  this->ParameterEvaluator_ = s;
}

const Region_Type::AggregateEvaluator_sequence& Region_Type::
AggregateEvaluator () const
{
  return this->AggregateEvaluator_;
}

Region_Type::AggregateEvaluator_sequence& Region_Type::
AggregateEvaluator ()
{
  return this->AggregateEvaluator_;
}

void Region_Type::
AggregateEvaluator (const AggregateEvaluator_sequence& s)
{
  this->AggregateEvaluator_ = s;
}

const Region_Type::name_type& Region_Type::
name () const
{
  return this->name_.get ();
}

Region_Type::name_type& Region_Type::
name ()
{
  return this->name_.get ();
}

void Region_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void Region_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}


// Fieldml_Type
// 

const Fieldml_Type::Region_type& Fieldml_Type::
Region () const
{
  return this->Region_.get ();
}

Fieldml_Type::Region_type& Fieldml_Type::
Region ()
{
  return this->Region_.get ();
}

void Fieldml_Type::
Region (const Region_type& x)
{
  this->Region_.set (x);
}

void Fieldml_Type::
Region (::std::unique_ptr< Region_type > x)
{
  this->Region_.set (std::move (x));
}

const Fieldml_Type::version_optional& Fieldml_Type::
version () const
{
  return this->version_;
}

Fieldml_Type::version_optional& Fieldml_Type::
version ()
{
  return this->version_;
}

void Fieldml_Type::
version (const version_type& x)
{
  this->version_.set (x);
}

void Fieldml_Type::
version (const version_optional& x)
{
  this->version_ = x;
}

void Fieldml_Type::
version (::std::unique_ptr< version_type > x)
{
  this->version_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// FieldmlRdfTargetType
//

FieldmlRdfTargetType::
FieldmlRdfTargetType ()
: ::xml_schema::type (),
  id_ (this)
{
}

FieldmlRdfTargetType::
FieldmlRdfTargetType (const FieldmlRdfTargetType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this)
{
}

FieldmlRdfTargetType::
FieldmlRdfTargetType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FieldmlRdfTargetType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

FieldmlRdfTargetType* FieldmlRdfTargetType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FieldmlRdfTargetType (*this, f, c);
}

FieldmlRdfTargetType& FieldmlRdfTargetType::
operator= (const FieldmlRdfTargetType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

FieldmlRdfTargetType::
~FieldmlRdfTargetType ()
{
}

// FieldmlObject_Type
//

FieldmlObject_Type::
FieldmlObject_Type (const name_type& name)
: ::FieldmlRdfTargetType (),
  name_ (name, this)
{
}

FieldmlObject_Type::
FieldmlObject_Type (const FieldmlObject_Type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::FieldmlRdfTargetType (x, f, c),
  name_ (x.name_, f, this)
{
}

FieldmlObject_Type::
FieldmlObject_Type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::FieldmlRdfTargetType (e, f | ::xml_schema::flags::base, c),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void FieldmlObject_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlRdfTargetType::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

FieldmlObject_Type* FieldmlObject_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FieldmlObject_Type (*this, f, c);
}

FieldmlObject_Type& FieldmlObject_Type::
operator= (const FieldmlObject_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlRdfTargetType& > (*this) = x;
    this->name_ = x.name_;
  }

  return *this;
}

FieldmlObject_Type::
~FieldmlObject_Type ()
{
}

// ArrayDataSize_Type
//

ArrayDataSize_Type::
ArrayDataSize_Type ()
: ::xml_schema::string ()
{
}

ArrayDataSize_Type::
ArrayDataSize_Type (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

ArrayDataSize_Type::
ArrayDataSize_Type (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

ArrayDataSize_Type::
ArrayDataSize_Type (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

ArrayDataSize_Type::
ArrayDataSize_Type (const ArrayDataSize_Type& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

ArrayDataSize_Type::
ArrayDataSize_Type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

ArrayDataSize_Type::
ArrayDataSize_Type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

ArrayDataSize_Type::
ArrayDataSize_Type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

ArrayDataSize_Type* ArrayDataSize_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ArrayDataSize_Type (*this, f, c);
}

ArrayDataSize_Type::
~ArrayDataSize_Type ()
{
}

// ArrayDataOffset_Type
//

ArrayDataOffset_Type::
ArrayDataOffset_Type ()
: ::xml_schema::string ()
{
}

ArrayDataOffset_Type::
ArrayDataOffset_Type (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

ArrayDataOffset_Type::
ArrayDataOffset_Type (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

ArrayDataOffset_Type::
ArrayDataOffset_Type (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

ArrayDataOffset_Type::
ArrayDataOffset_Type (const ArrayDataOffset_Type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

ArrayDataOffset_Type::
ArrayDataOffset_Type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

ArrayDataOffset_Type::
ArrayDataOffset_Type (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

ArrayDataOffset_Type::
ArrayDataOffset_Type (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

ArrayDataOffset_Type* ArrayDataOffset_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ArrayDataOffset_Type (*this, f, c);
}

ArrayDataOffset_Type::
~ArrayDataOffset_Type ()
{
}

// RawArraySize_Type
//

RawArraySize_Type::
RawArraySize_Type ()
: ::xml_schema::string ()
{
}

RawArraySize_Type::
RawArraySize_Type (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

RawArraySize_Type::
RawArraySize_Type (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

RawArraySize_Type::
RawArraySize_Type (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

RawArraySize_Type::
RawArraySize_Type (const RawArraySize_Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

RawArraySize_Type::
RawArraySize_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

RawArraySize_Type::
RawArraySize_Type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

RawArraySize_Type::
RawArraySize_Type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

RawArraySize_Type* RawArraySize_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RawArraySize_Type (*this, f, c);
}

RawArraySize_Type::
~RawArraySize_Type ()
{
}

// ArrayDataSource_Type
//

ArrayDataSource_Type::
ArrayDataSource_Type (const name_type& name,
                      const location_type& location,
                      const rank_type& rank)
: ::xml_schema::type (),
  ArrayDataSize_ (this),
  ArrayDataOffset_ (this),
  RawArraySize_ (this),
  name_ (name, this),
  location_ (location, this),
  rank_ (rank, this)
{
}

ArrayDataSource_Type::
ArrayDataSource_Type (const ArrayDataSource_Type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ArrayDataSize_ (x.ArrayDataSize_, f, this),
  ArrayDataOffset_ (x.ArrayDataOffset_, f, this),
  RawArraySize_ (x.RawArraySize_, f, this),
  name_ (x.name_, f, this),
  location_ (x.location_, f, this),
  rank_ (x.rank_, f, this)
{
}

ArrayDataSource_Type::
ArrayDataSource_Type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ArrayDataSize_ (this),
  ArrayDataOffset_ (this),
  RawArraySize_ (this),
  name_ (this),
  location_ (this),
  rank_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ArrayDataSource_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ArrayDataSize
    //
    if (n.name () == "ArrayDataSize" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ArrayDataSize_type > r (
        ArrayDataSize_traits::create (i, f, this));

      this->ArrayDataSize_.push_back (::std::move (r));
      continue;
    }

    // ArrayDataOffset
    //
    if (n.name () == "ArrayDataOffset" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ArrayDataOffset_type > r (
        ArrayDataOffset_traits::create (i, f, this));

      this->ArrayDataOffset_.push_back (::std::move (r));
      continue;
    }

    // RawArraySize
    //
    if (n.name () == "RawArraySize" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< RawArraySize_type > r (
        RawArraySize_traits::create (i, f, this));

      this->RawArraySize_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "location" && n.namespace_ ().empty ())
    {
      this->location_.set (location_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rank" && n.namespace_ ().empty ())
    {
      this->rank_.set (rank_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!location_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "location",
      "");
  }

  if (!rank_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "rank",
      "");
  }
}

ArrayDataSource_Type* ArrayDataSource_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ArrayDataSource_Type (*this, f, c);
}

ArrayDataSource_Type& ArrayDataSource_Type::
operator= (const ArrayDataSource_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ArrayDataSize_ = x.ArrayDataSize_;
    this->ArrayDataOffset_ = x.ArrayDataOffset_;
    this->RawArraySize_ = x.RawArraySize_;
    this->name_ = x.name_;
    this->location_ = x.location_;
    this->rank_ = x.rank_;
  }

  return *this;
}

ArrayDataSource_Type::
~ArrayDataSource_Type ()
{
}

// DataResourceHref_Type
//

DataResourceHref_Type::
DataResourceHref_Type (const href_type& href,
                       const format_type& format)
: ::xml_schema::type (),
  href_ (href, this),
  format_ (format, this)
{
}

DataResourceHref_Type::
DataResourceHref_Type (const DataResourceHref_Type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  href_ (x.href_, f, this),
  format_ (x.format_, f, this)
{
}

DataResourceHref_Type::
DataResourceHref_Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  href_ (this),
  format_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void DataResourceHref_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "href" && n.namespace_ () == "http://www.w3.org/1999/xlink")
    {
      this->href_.set (href_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "format" && n.namespace_ ().empty ())
    {
      this->format_.set (format_traits::create (i, f, this));
      continue;
    }
  }

  if (!href_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "href",
      "http://www.w3.org/1999/xlink");
  }

  if (!format_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "format",
      "");
  }
}

DataResourceHref_Type* DataResourceHref_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataResourceHref_Type (*this, f, c);
}

DataResourceHref_Type& DataResourceHref_Type::
operator= (const DataResourceHref_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->href_ = x.href_;
    this->format_ = x.format_;
  }

  return *this;
}

DataResourceHref_Type::
~DataResourceHref_Type ()
{
}

// DataResourceString_Type
//

DataResourceString_Type::
DataResourceString_Type ()
: ::xml_schema::string ()
{
}

DataResourceString_Type::
DataResourceString_Type (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

DataResourceString_Type::
DataResourceString_Type (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

DataResourceString_Type::
DataResourceString_Type (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

DataResourceString_Type::
DataResourceString_Type (const DataResourceString_Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

DataResourceString_Type::
DataResourceString_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

DataResourceString_Type::
DataResourceString_Type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

DataResourceString_Type::
DataResourceString_Type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

DataResourceString_Type* DataResourceString_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataResourceString_Type (*this, f, c);
}

DataResourceString_Type::
~DataResourceString_Type ()
{
}

// DataResourceDescription_Type
//

DataResourceDescription_Type::
DataResourceDescription_Type ()
: ::xml_schema::type (),
  DataResourceHref_ (this),
  DataResourceString_ (this)
{
}

DataResourceDescription_Type::
DataResourceDescription_Type (const DataResourceDescription_Type& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DataResourceHref_ (x.DataResourceHref_, f, this),
  DataResourceString_ (x.DataResourceString_, f, this)
{
}

DataResourceDescription_Type::
DataResourceDescription_Type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DataResourceHref_ (this),
  DataResourceString_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DataResourceDescription_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DataResourceHref
    //
    if (n.name () == "DataResourceHref" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DataResourceHref_type > r (
        DataResourceHref_traits::create (i, f, this));

      if (!this->DataResourceHref_)
      {
        this->DataResourceHref_.set (::std::move (r));
        continue;
      }
    }

    // DataResourceString
    //
    if (n.name () == "DataResourceString" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DataResourceString_type > r (
        DataResourceString_traits::create (i, f, this));

      if (!this->DataResourceString_)
      {
        this->DataResourceString_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

DataResourceDescription_Type* DataResourceDescription_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataResourceDescription_Type (*this, f, c);
}

DataResourceDescription_Type& DataResourceDescription_Type::
operator= (const DataResourceDescription_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DataResourceHref_ = x.DataResourceHref_;
    this->DataResourceString_ = x.DataResourceString_;
  }

  return *this;
}

DataResourceDescription_Type::
~DataResourceDescription_Type ()
{
}

// DataResource_Type
//

DataResource_Type::
DataResource_Type (const name_type& name)
: ::xml_schema::type (),
  DataResourceDescription_ (this),
  ArrayDataSource_ (this),
  name_ (name, this)
{
}

DataResource_Type::
DataResource_Type (const DataResource_Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DataResourceDescription_ (x.DataResourceDescription_, f, this),
  ArrayDataSource_ (x.ArrayDataSource_, f, this),
  name_ (x.name_, f, this)
{
}

DataResource_Type::
DataResource_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DataResourceDescription_ (this),
  ArrayDataSource_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void DataResource_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DataResourceDescription
    //
    if (n.name () == "DataResourceDescription" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DataResourceDescription_type > r (
        DataResourceDescription_traits::create (i, f, this));

      this->DataResourceDescription_.push_back (::std::move (r));
      continue;
    }

    // ArrayDataSource
    //
    if (n.name () == "ArrayDataSource" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ArrayDataSource_type > r (
        ArrayDataSource_traits::create (i, f, this));

      this->ArrayDataSource_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

DataResource_Type* DataResource_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataResource_Type (*this, f, c);
}

DataResource_Type& DataResource_Type::
operator= (const DataResource_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DataResourceDescription_ = x.DataResourceDescription_;
    this->ArrayDataSource_ = x.ArrayDataSource_;
    this->name_ = x.name_;
  }

  return *this;
}

DataResource_Type::
~DataResource_Type ()
{
}

// ImportTypeEntry_Type
//

ImportTypeEntry_Type::
ImportTypeEntry_Type (const localName_type& localName,
                      const remoteName_type& remoteName)
: ::xml_schema::type (),
  localName_ (localName, this),
  remoteName_ (remoteName, this)
{
}

ImportTypeEntry_Type::
ImportTypeEntry_Type (const ImportTypeEntry_Type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  localName_ (x.localName_, f, this),
  remoteName_ (x.remoteName_, f, this)
{
}

ImportTypeEntry_Type::
ImportTypeEntry_Type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  localName_ (this),
  remoteName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ImportTypeEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "localName" && n.namespace_ ().empty ())
    {
      this->localName_.set (localName_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "remoteName" && n.namespace_ ().empty ())
    {
      this->remoteName_.set (remoteName_traits::create (i, f, this));
      continue;
    }
  }

  if (!localName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "localName",
      "");
  }

  if (!remoteName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "remoteName",
      "");
  }
}

ImportTypeEntry_Type* ImportTypeEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ImportTypeEntry_Type (*this, f, c);
}

ImportTypeEntry_Type& ImportTypeEntry_Type::
operator= (const ImportTypeEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->localName_ = x.localName_;
    this->remoteName_ = x.remoteName_;
  }

  return *this;
}

ImportTypeEntry_Type::
~ImportTypeEntry_Type ()
{
}

// ImportEvaluatorEntry_Type
//

ImportEvaluatorEntry_Type::
ImportEvaluatorEntry_Type (const localName_type& localName,
                           const remoteName_type& remoteName)
: ::xml_schema::type (),
  localName_ (localName, this),
  remoteName_ (remoteName, this)
{
}

ImportEvaluatorEntry_Type::
ImportEvaluatorEntry_Type (const ImportEvaluatorEntry_Type& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  localName_ (x.localName_, f, this),
  remoteName_ (x.remoteName_, f, this)
{
}

ImportEvaluatorEntry_Type::
ImportEvaluatorEntry_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  localName_ (this),
  remoteName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ImportEvaluatorEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "localName" && n.namespace_ ().empty ())
    {
      this->localName_.set (localName_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "remoteName" && n.namespace_ ().empty ())
    {
      this->remoteName_.set (remoteName_traits::create (i, f, this));
      continue;
    }
  }

  if (!localName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "localName",
      "");
  }

  if (!remoteName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "remoteName",
      "");
  }
}

ImportEvaluatorEntry_Type* ImportEvaluatorEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ImportEvaluatorEntry_Type (*this, f, c);
}

ImportEvaluatorEntry_Type& ImportEvaluatorEntry_Type::
operator= (const ImportEvaluatorEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->localName_ = x.localName_;
    this->remoteName_ = x.remoteName_;
  }

  return *this;
}

ImportEvaluatorEntry_Type::
~ImportEvaluatorEntry_Type ()
{
}

// Import_Type
//

Import_Type::
Import_Type (const href_type& href,
             const region_type& region)
: ::xml_schema::type (),
  ImportType_ (this),
  ImportEvaluator_ (this),
  href_ (href, this),
  region_ (region, this)
{
}

Import_Type::
Import_Type (const Import_Type& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ImportType_ (x.ImportType_, f, this),
  ImportEvaluator_ (x.ImportEvaluator_, f, this),
  href_ (x.href_, f, this),
  region_ (x.region_, f, this)
{
}

Import_Type::
Import_Type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ImportType_ (this),
  ImportEvaluator_ (this),
  href_ (this),
  region_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Import_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ImportType
    //
    if (n.name () == "ImportType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ImportType_type > r (
        ImportType_traits::create (i, f, this));

      this->ImportType_.push_back (::std::move (r));
      continue;
    }

    // ImportEvaluator
    //
    if (n.name () == "ImportEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ImportEvaluator_type > r (
        ImportEvaluator_traits::create (i, f, this));

      this->ImportEvaluator_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "href" && n.namespace_ () == "http://www.w3.org/1999/xlink")
    {
      this->href_.set (href_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "region" && n.namespace_ ().empty ())
    {
      this->region_.set (region_traits::create (i, f, this));
      continue;
    }
  }

  if (!href_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "href",
      "http://www.w3.org/1999/xlink");
  }

  if (!region_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "region",
      "");
  }
}

Import_Type* Import_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Import_Type (*this, f, c);
}

Import_Type& Import_Type::
operator= (const Import_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ImportType_ = x.ImportType_;
    this->ImportEvaluator_ = x.ImportEvaluator_;
    this->href_ = x.href_;
    this->region_ = x.region_;
  }

  return *this;
}

Import_Type::
~Import_Type ()
{
}

// NumberedIndexEvaluator_Type
//

NumberedIndexEvaluator_Type::
NumberedIndexEvaluator_Type (const evaluator_type& evaluator,
                             const indexNumber_type& indexNumber)
: ::xml_schema::type (),
  evaluator_ (evaluator, this),
  indexNumber_ (indexNumber, this)
{
}

NumberedIndexEvaluator_Type::
NumberedIndexEvaluator_Type (const NumberedIndexEvaluator_Type& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  evaluator_ (x.evaluator_, f, this),
  indexNumber_ (x.indexNumber_, f, this)
{
}

NumberedIndexEvaluator_Type::
NumberedIndexEvaluator_Type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  evaluator_ (this),
  indexNumber_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void NumberedIndexEvaluator_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "evaluator" && n.namespace_ ().empty ())
    {
      this->evaluator_.set (evaluator_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "indexNumber" && n.namespace_ ().empty ())
    {
      this->indexNumber_.set (indexNumber_traits::create (i, f, this));
      continue;
    }
  }

  if (!evaluator_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "evaluator",
      "");
  }

  if (!indexNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "indexNumber",
      "");
  }
}

NumberedIndexEvaluator_Type* NumberedIndexEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NumberedIndexEvaluator_Type (*this, f, c);
}

NumberedIndexEvaluator_Type& NumberedIndexEvaluator_Type::
operator= (const NumberedIndexEvaluator_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->evaluator_ = x.evaluator_;
    this->indexNumber_ = x.indexNumber_;
  }

  return *this;
}

NumberedIndexEvaluator_Type::
~NumberedIndexEvaluator_Type ()
{
}

// NumberedIndexEvaluatorList_Type
//

NumberedIndexEvaluatorList_Type::
NumberedIndexEvaluatorList_Type ()
: ::xml_schema::type (),
  IndexEvaluator_ (this)
{
}

NumberedIndexEvaluatorList_Type::
NumberedIndexEvaluatorList_Type (const NumberedIndexEvaluatorList_Type& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  IndexEvaluator_ (x.IndexEvaluator_, f, this)
{
}

NumberedIndexEvaluatorList_Type::
NumberedIndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  IndexEvaluator_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NumberedIndexEvaluatorList_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IndexEvaluator
    //
    if (n.name () == "IndexEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< IndexEvaluator_type > r (
        IndexEvaluator_traits::create (i, f, this));

      this->IndexEvaluator_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

NumberedIndexEvaluatorList_Type* NumberedIndexEvaluatorList_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NumberedIndexEvaluatorList_Type (*this, f, c);
}

NumberedIndexEvaluatorList_Type& NumberedIndexEvaluatorList_Type::
operator= (const NumberedIndexEvaluatorList_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->IndexEvaluator_ = x.IndexEvaluator_;
  }

  return *this;
}

NumberedIndexEvaluatorList_Type::
~NumberedIndexEvaluatorList_Type ()
{
}

// BindMapEntry_Type
//

BindMapEntry_Type::
BindMapEntry_Type (const argument_type& argument,
                   const source_type& source)
: ::xml_schema::type (),
  argument_ (argument, this),
  source_ (source, this)
{
}

BindMapEntry_Type::
BindMapEntry_Type (const BindMapEntry_Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  argument_ (x.argument_, f, this),
  source_ (x.source_, f, this)
{
}

BindMapEntry_Type::
BindMapEntry_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  argument_ (this),
  source_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void BindMapEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "argument" && n.namespace_ ().empty ())
    {
      this->argument_.set (argument_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      this->source_.set (source_traits::create (i, f, this));
      continue;
    }
  }

  if (!argument_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "argument",
      "");
  }

  if (!source_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "source",
      "");
  }
}

BindMapEntry_Type* BindMapEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BindMapEntry_Type (*this, f, c);
}

BindMapEntry_Type& BindMapEntry_Type::
operator= (const BindMapEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->argument_ = x.argument_;
    this->source_ = x.source_;
  }

  return *this;
}

BindMapEntry_Type::
~BindMapEntry_Type ()
{
}

// BindMapIndexEntry_Type
//

BindMapIndexEntry_Type::
BindMapIndexEntry_Type (const argument_type& argument,
                        const indexNumber_type& indexNumber)
: ::xml_schema::type (),
  argument_ (argument, this),
  indexNumber_ (indexNumber, this)
{
}

BindMapIndexEntry_Type::
BindMapIndexEntry_Type (const BindMapIndexEntry_Type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  argument_ (x.argument_, f, this),
  indexNumber_ (x.indexNumber_, f, this)
{
}

BindMapIndexEntry_Type::
BindMapIndexEntry_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  argument_ (this),
  indexNumber_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void BindMapIndexEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "argument" && n.namespace_ ().empty ())
    {
      this->argument_.set (argument_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "indexNumber" && n.namespace_ ().empty ())
    {
      this->indexNumber_.set (indexNumber_traits::create (i, f, this));
      continue;
    }
  }

  if (!argument_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "argument",
      "");
  }

  if (!indexNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "indexNumber",
      "");
  }
}

BindMapIndexEntry_Type* BindMapIndexEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BindMapIndexEntry_Type (*this, f, c);
}

BindMapIndexEntry_Type& BindMapIndexEntry_Type::
operator= (const BindMapIndexEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->argument_ = x.argument_;
    this->indexNumber_ = x.indexNumber_;
  }

  return *this;
}

BindMapIndexEntry_Type::
~BindMapIndexEntry_Type ()
{
}

// BindMapWithIndexes_Type
//

BindMapWithIndexes_Type::
BindMapWithIndexes_Type ()
: ::xml_schema::type (),
  BindIndex_ (this),
  Bind_ (this)
{
}

BindMapWithIndexes_Type::
BindMapWithIndexes_Type (const BindMapWithIndexes_Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  BindIndex_ (x.BindIndex_, f, this),
  Bind_ (x.Bind_, f, this)
{
}

BindMapWithIndexes_Type::
BindMapWithIndexes_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  BindIndex_ (this),
  Bind_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BindMapWithIndexes_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // BindIndex
    //
    if (n.name () == "BindIndex" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< BindIndex_type > r (
        BindIndex_traits::create (i, f, this));

      this->BindIndex_.push_back (::std::move (r));
      continue;
    }

    // Bind
    //
    if (n.name () == "Bind" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Bind_type > r (
        Bind_traits::create (i, f, this));

      this->Bind_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

BindMapWithIndexes_Type* BindMapWithIndexes_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BindMapWithIndexes_Type (*this, f, c);
}

BindMapWithIndexes_Type& BindMapWithIndexes_Type::
operator= (const BindMapWithIndexes_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->BindIndex_ = x.BindIndex_;
    this->Bind_ = x.Bind_;
  }

  return *this;
}

BindMapWithIndexes_Type::
~BindMapWithIndexes_Type ()
{
}

// BindMap_Type
//

BindMap_Type::
BindMap_Type ()
: ::xml_schema::type (),
  Bind_ (this)
{
}

BindMap_Type::
BindMap_Type (const BindMap_Type& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Bind_ (x.Bind_, f, this)
{
}

BindMap_Type::
BindMap_Type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Bind_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BindMap_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Bind
    //
    if (n.name () == "Bind" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Bind_type > r (
        Bind_traits::create (i, f, this));

      this->Bind_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

BindMap_Type* BindMap_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BindMap_Type (*this, f, c);
}

BindMap_Type& BindMap_Type::
operator= (const BindMap_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Bind_ = x.Bind_;
  }

  return *this;
}

BindMap_Type::
~BindMap_Type ()
{
}

// ComponentEvaluatorsEntry_Type
//

ComponentEvaluatorsEntry_Type::
ComponentEvaluatorsEntry_Type (const component_type& component,
                               const evaluator_type& evaluator)
: ::xml_schema::type (),
  component_ (component, this),
  evaluator_ (evaluator, this)
{
}

ComponentEvaluatorsEntry_Type::
ComponentEvaluatorsEntry_Type (const ComponentEvaluatorsEntry_Type& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  component_ (x.component_, f, this),
  evaluator_ (x.evaluator_, f, this)
{
}

ComponentEvaluatorsEntry_Type::
ComponentEvaluatorsEntry_Type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  component_ (this),
  evaluator_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ComponentEvaluatorsEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "component" && n.namespace_ ().empty ())
    {
      this->component_.set (component_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "evaluator" && n.namespace_ ().empty ())
    {
      this->evaluator_.set (evaluator_traits::create (i, f, this));
      continue;
    }
  }

  if (!component_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "component",
      "");
  }

  if (!evaluator_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "evaluator",
      "");
  }
}

ComponentEvaluatorsEntry_Type* ComponentEvaluatorsEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ComponentEvaluatorsEntry_Type (*this, f, c);
}

ComponentEvaluatorsEntry_Type& ComponentEvaluatorsEntry_Type::
operator= (const ComponentEvaluatorsEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->component_ = x.component_;
    this->evaluator_ = x.evaluator_;
  }

  return *this;
}

ComponentEvaluatorsEntry_Type::
~ComponentEvaluatorsEntry_Type ()
{
}

// ComponentEvaluators_Type
//

ComponentEvaluators_Type::
ComponentEvaluators_Type ()
: ::xml_schema::type (),
  ComponentEvaluator_ (this),
  default__ (this)
{
}

ComponentEvaluators_Type::
ComponentEvaluators_Type (const ComponentEvaluators_Type& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ComponentEvaluator_ (x.ComponentEvaluator_, f, this),
  default__ (x.default__, f, this)
{
}

ComponentEvaluators_Type::
ComponentEvaluators_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ComponentEvaluator_ (this),
  default__ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ComponentEvaluators_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ComponentEvaluator
    //
    if (n.name () == "ComponentEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ComponentEvaluator_type > r (
        ComponentEvaluator_traits::create (i, f, this));

      this->ComponentEvaluator_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "default" && n.namespace_ ().empty ())
    {
      this->default__.set (default_traits::create (i, f, this));
      continue;
    }
  }
}

ComponentEvaluators_Type* ComponentEvaluators_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ComponentEvaluators_Type (*this, f, c);
}

ComponentEvaluators_Type& ComponentEvaluators_Type::
operator= (const ComponentEvaluators_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ComponentEvaluator_ = x.ComponentEvaluator_;
    this->default__ = x.default__;
  }

  return *this;
}

ComponentEvaluators_Type::
~ComponentEvaluators_Type ()
{
}

// ShapeMap_Type
//

ShapeMap_Type::
ShapeMap_Type (const evaluator_type& evaluator)
: ::xml_schema::type (),
  evaluator_ (evaluator, this)
{
}

ShapeMap_Type::
ShapeMap_Type (const ShapeMap_Type& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  evaluator_ (x.evaluator_, f, this)
{
}

ShapeMap_Type::
ShapeMap_Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  evaluator_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ShapeMap_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "evaluator" && n.namespace_ ().empty ())
    {
      this->evaluator_.set (evaluator_traits::create (i, f, this));
      continue;
    }
  }

  if (!evaluator_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "evaluator",
      "");
  }
}

ShapeMap_Type* ShapeMap_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ShapeMap_Type (*this, f, c);
}

ShapeMap_Type& ShapeMap_Type::
operator= (const ShapeMap_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->evaluator_ = x.evaluator_;
  }

  return *this;
}

ShapeMap_Type::
~ShapeMap_Type ()
{
}

// ArgumentListEntry_Type
//

ArgumentListEntry_Type::
ArgumentListEntry_Type (const name_type& name)
: ::xml_schema::type (),
  name_ (name, this)
{
}

ArgumentListEntry_Type::
ArgumentListEntry_Type (const ArgumentListEntry_Type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this)
{
}

ArgumentListEntry_Type::
ArgumentListEntry_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ArgumentListEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

ArgumentListEntry_Type* ArgumentListEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ArgumentListEntry_Type (*this, f, c);
}

ArgumentListEntry_Type& ArgumentListEntry_Type::
operator= (const ArgumentListEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
  }

  return *this;
}

ArgumentListEntry_Type::
~ArgumentListEntry_Type ()
{
}

// ArgumentList_Type
//

ArgumentList_Type::
ArgumentList_Type ()
: ::xml_schema::type (),
  Argument_ (this)
{
}

ArgumentList_Type::
ArgumentList_Type (const ArgumentList_Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Argument_ (x.Argument_, f, this)
{
}

ArgumentList_Type::
ArgumentList_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Argument_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ArgumentList_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Argument
    //
    if (n.name () == "Argument" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Argument_type > r (
        Argument_traits::create (i, f, this));

      this->Argument_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

ArgumentList_Type* ArgumentList_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ArgumentList_Type (*this, f, c);
}

ArgumentList_Type& ArgumentList_Type::
operator= (const ArgumentList_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Argument_ = x.Argument_;
  }

  return *this;
}

ArgumentList_Type::
~ArgumentList_Type ()
{
}

// EvaluatorListEntry_Type
//

EvaluatorListEntry_Type::
EvaluatorListEntry_Type (const evaluator_type& evaluator)
: ::xml_schema::type (),
  evaluator_ (evaluator, this)
{
}

EvaluatorListEntry_Type::
EvaluatorListEntry_Type (const EvaluatorListEntry_Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  evaluator_ (x.evaluator_, f, this)
{
}

EvaluatorListEntry_Type::
EvaluatorListEntry_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  evaluator_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void EvaluatorListEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "evaluator" && n.namespace_ ().empty ())
    {
      this->evaluator_.set (evaluator_traits::create (i, f, this));
      continue;
    }
  }

  if (!evaluator_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "evaluator",
      "");
  }
}

EvaluatorListEntry_Type* EvaluatorListEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EvaluatorListEntry_Type (*this, f, c);
}

EvaluatorListEntry_Type& EvaluatorListEntry_Type::
operator= (const EvaluatorListEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->evaluator_ = x.evaluator_;
  }

  return *this;
}

EvaluatorListEntry_Type::
~EvaluatorListEntry_Type ()
{
}

// IndexEvaluatorList_Type
//

IndexEvaluatorList_Type::
IndexEvaluatorList_Type ()
: ::xml_schema::type (),
  IndexEvaluator_ (this)
{
}

IndexEvaluatorList_Type::
IndexEvaluatorList_Type (const IndexEvaluatorList_Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  IndexEvaluator_ (x.IndexEvaluator_, f, this)
{
}

IndexEvaluatorList_Type::
IndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  IndexEvaluator_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IndexEvaluatorList_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IndexEvaluator
    //
    if (n.name () == "IndexEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< IndexEvaluator_type > r (
        IndexEvaluator_traits::create (i, f, this));

      this->IndexEvaluator_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

IndexEvaluatorList_Type* IndexEvaluatorList_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IndexEvaluatorList_Type (*this, f, c);
}

IndexEvaluatorList_Type& IndexEvaluatorList_Type::
operator= (const IndexEvaluatorList_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->IndexEvaluator_ = x.IndexEvaluator_;
  }

  return *this;
}

IndexEvaluatorList_Type::
~IndexEvaluatorList_Type ()
{
}

// OrderedEvaluatorListEntry_Type
//

OrderedEvaluatorListEntry_Type::
OrderedEvaluatorListEntry_Type (const evaluator_type& evaluator)
: ::xml_schema::type (),
  evaluator_ (evaluator, this),
  order_ (this)
{
}

OrderedEvaluatorListEntry_Type::
OrderedEvaluatorListEntry_Type (const OrderedEvaluatorListEntry_Type& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  evaluator_ (x.evaluator_, f, this),
  order_ (x.order_, f, this)
{
}

OrderedEvaluatorListEntry_Type::
OrderedEvaluatorListEntry_Type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  evaluator_ (this),
  order_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void OrderedEvaluatorListEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "evaluator" && n.namespace_ ().empty ())
    {
      this->evaluator_.set (evaluator_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "order" && n.namespace_ ().empty ())
    {
      this->order_.set (order_traits::create (i, f, this));
      continue;
    }
  }

  if (!evaluator_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "evaluator",
      "");
  }
}

OrderedEvaluatorListEntry_Type* OrderedEvaluatorListEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OrderedEvaluatorListEntry_Type (*this, f, c);
}

OrderedEvaluatorListEntry_Type& OrderedEvaluatorListEntry_Type::
operator= (const OrderedEvaluatorListEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->evaluator_ = x.evaluator_;
    this->order_ = x.order_;
  }

  return *this;
}

OrderedEvaluatorListEntry_Type::
~OrderedEvaluatorListEntry_Type ()
{
}

// OrderedIndexEvaluatorList_Type
//

OrderedIndexEvaluatorList_Type::
OrderedIndexEvaluatorList_Type ()
: ::xml_schema::type (),
  IndexEvaluator_ (this)
{
}

OrderedIndexEvaluatorList_Type::
OrderedIndexEvaluatorList_Type (const OrderedIndexEvaluatorList_Type& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  IndexEvaluator_ (x.IndexEvaluator_, f, this)
{
}

OrderedIndexEvaluatorList_Type::
OrderedIndexEvaluatorList_Type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  IndexEvaluator_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OrderedIndexEvaluatorList_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IndexEvaluator
    //
    if (n.name () == "IndexEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< IndexEvaluator_type > r (
        IndexEvaluator_traits::create (i, f, this));

      this->IndexEvaluator_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

OrderedIndexEvaluatorList_Type* OrderedIndexEvaluatorList_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OrderedIndexEvaluatorList_Type (*this, f, c);
}

OrderedIndexEvaluatorList_Type& OrderedIndexEvaluatorList_Type::
operator= (const OrderedIndexEvaluatorList_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->IndexEvaluator_ = x.IndexEvaluator_;
  }

  return *this;
}

OrderedIndexEvaluatorList_Type::
~OrderedIndexEvaluatorList_Type ()
{
}

// MemberRange_Type
//

MemberRange_Type::
MemberRange_Type (const min_type& min,
                  const max_type& max)
: ::xml_schema::type (),
  min_ (min, this),
  max_ (max, this),
  stride_ (this)
{
}

MemberRange_Type::
MemberRange_Type (const MemberRange_Type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  min_ (x.min_, f, this),
  max_ (x.max_, f, this),
  stride_ (x.stride_, f, this)
{
}

MemberRange_Type::
MemberRange_Type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  min_ (this),
  max_ (this),
  stride_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void MemberRange_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "min" && n.namespace_ ().empty ())
    {
      this->min_.set (min_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "max" && n.namespace_ ().empty ())
    {
      this->max_.set (max_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "stride" && n.namespace_ ().empty ())
    {
      this->stride_.set (stride_traits::create (i, f, this));
      continue;
    }
  }

  if (!min_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "min",
      "");
  }

  if (!max_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "max",
      "");
  }
}

MemberRange_Type* MemberRange_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MemberRange_Type (*this, f, c);
}

MemberRange_Type& MemberRange_Type::
operator= (const MemberRange_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->min_ = x.min_;
    this->max_ = x.max_;
    this->stride_ = x.stride_;
  }

  return *this;
}

MemberRange_Type::
~MemberRange_Type ()
{
}

// MemberData_Type
//

MemberData_Type::
MemberData_Type (const count_type& count,
                 const data_type& data)
: ::xml_schema::type (),
  count_ (count, this),
  data_ (data, this)
{
}

MemberData_Type::
MemberData_Type (const MemberData_Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  count_ (x.count_, f, this),
  data_ (x.data_, f, this)
{
}

MemberData_Type::
MemberData_Type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  count_ (this),
  data_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void MemberData_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "count" && n.namespace_ ().empty ())
    {
      this->count_.set (count_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "data" && n.namespace_ ().empty ())
    {
      this->data_.set (data_traits::create (i, f, this));
      continue;
    }
  }

  if (!count_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "count",
      "");
  }

  if (!data_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "data",
      "");
  }
}

MemberData_Type* MemberData_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MemberData_Type (*this, f, c);
}

MemberData_Type& MemberData_Type::
operator= (const MemberData_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->count_ = x.count_;
    this->data_ = x.data_;
  }

  return *this;
}

MemberData_Type::
~MemberData_Type ()
{
}

// EnsembleMembers_Type
//

EnsembleMembers_Type::
EnsembleMembers_Type ()
: ::xml_schema::type (),
  MemberListData_ (this),
  MemberRangeData_ (this),
  MemberStrideRangeData_ (this),
  MemberRange_ (this)
{
}

EnsembleMembers_Type::
EnsembleMembers_Type (const EnsembleMembers_Type& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  MemberListData_ (x.MemberListData_, f, this),
  MemberRangeData_ (x.MemberRangeData_, f, this),
  MemberStrideRangeData_ (x.MemberStrideRangeData_, f, this),
  MemberRange_ (x.MemberRange_, f, this)
{
}

EnsembleMembers_Type::
EnsembleMembers_Type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  MemberListData_ (this),
  MemberRangeData_ (this),
  MemberStrideRangeData_ (this),
  MemberRange_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void EnsembleMembers_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MemberListData
    //
    if (n.name () == "MemberListData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< MemberListData_type > r (
        MemberListData_traits::create (i, f, this));

      if (!this->MemberListData_)
      {
        this->MemberListData_.set (::std::move (r));
        continue;
      }
    }

    // MemberRangeData
    //
    if (n.name () == "MemberRangeData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< MemberRangeData_type > r (
        MemberRangeData_traits::create (i, f, this));

      if (!this->MemberRangeData_)
      {
        this->MemberRangeData_.set (::std::move (r));
        continue;
      }
    }

    // MemberStrideRangeData
    //
    if (n.name () == "MemberStrideRangeData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< MemberStrideRangeData_type > r (
        MemberStrideRangeData_traits::create (i, f, this));

      if (!this->MemberStrideRangeData_)
      {
        this->MemberStrideRangeData_.set (::std::move (r));
        continue;
      }
    }

    // MemberRange
    //
    if (n.name () == "MemberRange" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< MemberRange_type > r (
        MemberRange_traits::create (i, f, this));

      if (!this->MemberRange_)
      {
        this->MemberRange_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

EnsembleMembers_Type* EnsembleMembers_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EnsembleMembers_Type (*this, f, c);
}

EnsembleMembers_Type& EnsembleMembers_Type::
operator= (const EnsembleMembers_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->MemberListData_ = x.MemberListData_;
    this->MemberRangeData_ = x.MemberRangeData_;
    this->MemberStrideRangeData_ = x.MemberStrideRangeData_;
    this->MemberRange_ = x.MemberRange_;
  }

  return *this;
}

EnsembleMembers_Type::
~EnsembleMembers_Type ()
{
}

// BooleanType_Type
//

BooleanType_Type::
BooleanType_Type (const name_type& name)
: ::FieldmlObject_Type (name)
{
}

BooleanType_Type::
BooleanType_Type (const BooleanType_Type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::FieldmlObject_Type (x, f, c)
{
}

BooleanType_Type::
BooleanType_Type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::FieldmlObject_Type (e, f, c)
{
}

BooleanType_Type* BooleanType_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BooleanType_Type (*this, f, c);
}

BooleanType_Type::
~BooleanType_Type ()
{
}

// EnsembleType_Type
//

EnsembleType_Type::
EnsembleType_Type (const name_type& name,
                   const Members_type& Members)
: ::FieldmlObject_Type (name),
  Members_ (Members, this)
{
}

EnsembleType_Type::
EnsembleType_Type (const name_type& name,
                   ::std::unique_ptr< Members_type > Members)
: ::FieldmlObject_Type (name),
  Members_ (std::move (Members), this)
{
}

EnsembleType_Type::
EnsembleType_Type (const EnsembleType_Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::FieldmlObject_Type (x, f, c),
  Members_ (x.Members_, f, this)
{
}

EnsembleType_Type::
EnsembleType_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::FieldmlObject_Type (e, f | ::xml_schema::flags::base, c),
  Members_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void EnsembleType_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlObject_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Members
    //
    if (n.name () == "Members" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Members_type > r (
        Members_traits::create (i, f, this));

      if (!Members_.present ())
      {
        this->Members_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Members_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Members",
      "");
  }
}

EnsembleType_Type* EnsembleType_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EnsembleType_Type (*this, f, c);
}

EnsembleType_Type& EnsembleType_Type::
operator= (const EnsembleType_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlObject_Type& > (*this) = x;
    this->Members_ = x.Members_;
  }

  return *this;
}

EnsembleType_Type::
~EnsembleType_Type ()
{
}

// ContinuousComponent_Type
//

ContinuousComponent_Type::
ContinuousComponent_Type (const name_type& name,
                          const count_type& count)
: ::xml_schema::type (),
  name_ (name, this),
  count_ (count, this)
{
}

ContinuousComponent_Type::
ContinuousComponent_Type (const ContinuousComponent_Type& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  count_ (x.count_, f, this)
{
}

ContinuousComponent_Type::
ContinuousComponent_Type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  count_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ContinuousComponent_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "count" && n.namespace_ ().empty ())
    {
      this->count_.set (count_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!count_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "count",
      "");
  }
}

ContinuousComponent_Type* ContinuousComponent_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ContinuousComponent_Type (*this, f, c);
}

ContinuousComponent_Type& ContinuousComponent_Type::
operator= (const ContinuousComponent_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->count_ = x.count_;
  }

  return *this;
}

ContinuousComponent_Type::
~ContinuousComponent_Type ()
{
}

// ContinuousType_Type
//

ContinuousType_Type::
ContinuousType_Type (const name_type& name)
: ::FieldmlObject_Type (name),
  Components_ (this)
{
}

ContinuousType_Type::
ContinuousType_Type (const ContinuousType_Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::FieldmlObject_Type (x, f, c),
  Components_ (x.Components_, f, this)
{
}

ContinuousType_Type::
ContinuousType_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::FieldmlObject_Type (e, f | ::xml_schema::flags::base, c),
  Components_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ContinuousType_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlObject_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Components
    //
    if (n.name () == "Components" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Components_type > r (
        Components_traits::create (i, f, this));

      if (!this->Components_)
      {
        this->Components_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

ContinuousType_Type* ContinuousType_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ContinuousType_Type (*this, f, c);
}

ContinuousType_Type& ContinuousType_Type::
operator= (const ContinuousType_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlObject_Type& > (*this) = x;
    this->Components_ = x.Components_;
  }

  return *this;
}

ContinuousType_Type::
~ContinuousType_Type ()
{
}

// MeshType_Type
//

MeshType_Type::
MeshType_Type (const name_type& name,
               const Elements_type& Elements,
               const Chart_type& Chart,
               const Shapes_type& Shapes)
: ::FieldmlObject_Type (name),
  Elements_ (Elements, this),
  Chart_ (Chart, this),
  Shapes_ (Shapes, this)
{
}

MeshType_Type::
MeshType_Type (const name_type& name,
               ::std::unique_ptr< Elements_type > Elements,
               ::std::unique_ptr< Chart_type > Chart,
               ::std::unique_ptr< Shapes_type > Shapes)
: ::FieldmlObject_Type (name),
  Elements_ (std::move (Elements), this),
  Chart_ (std::move (Chart), this),
  Shapes_ (std::move (Shapes), this)
{
}

MeshType_Type::
MeshType_Type (const MeshType_Type& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::FieldmlObject_Type (x, f, c),
  Elements_ (x.Elements_, f, this),
  Chart_ (x.Chart_, f, this),
  Shapes_ (x.Shapes_, f, this)
{
}

MeshType_Type::
MeshType_Type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::FieldmlObject_Type (e, f | ::xml_schema::flags::base, c),
  Elements_ (this),
  Chart_ (this),
  Shapes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MeshType_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlObject_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Elements
    //
    if (n.name () == "Elements" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Elements_type > r (
        Elements_traits::create (i, f, this));

      if (!Elements_.present ())
      {
        this->Elements_.set (::std::move (r));
        continue;
      }
    }

    // Chart
    //
    if (n.name () == "Chart" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Chart_type > r (
        Chart_traits::create (i, f, this));

      if (!Chart_.present ())
      {
        this->Chart_.set (::std::move (r));
        continue;
      }
    }

    // Shapes
    //
    if (n.name () == "Shapes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Shapes_type > r (
        Shapes_traits::create (i, f, this));

      if (!Shapes_.present ())
      {
        this->Shapes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Elements_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Elements",
      "");
  }

  if (!Chart_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Chart",
      "");
  }

  if (!Shapes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Shapes",
      "");
  }
}

MeshType_Type* MeshType_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MeshType_Type (*this, f, c);
}

MeshType_Type& MeshType_Type::
operator= (const MeshType_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlObject_Type& > (*this) = x;
    this->Elements_ = x.Elements_;
    this->Chart_ = x.Chart_;
    this->Shapes_ = x.Shapes_;
  }

  return *this;
}

MeshType_Type::
~MeshType_Type ()
{
}

// FieldmlEvaluator_Type
//

FieldmlEvaluator_Type::
FieldmlEvaluator_Type (const name_type& name,
                       const valueType_type& valueType)
: ::FieldmlObject_Type (name),
  Arguments_ (this),
  valueType_ (valueType, this)
{
}

FieldmlEvaluator_Type::
FieldmlEvaluator_Type (const FieldmlEvaluator_Type& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::FieldmlObject_Type (x, f, c),
  Arguments_ (x.Arguments_, f, this),
  valueType_ (x.valueType_, f, this)
{
}

FieldmlEvaluator_Type::
FieldmlEvaluator_Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::FieldmlObject_Type (e, f | ::xml_schema::flags::base, c),
  Arguments_ (this),
  valueType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FieldmlEvaluator_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlObject_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Arguments
    //
    if (n.name () == "Arguments" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Arguments_type > r (
        Arguments_traits::create (i, f, this));

      if (!this->Arguments_)
      {
        this->Arguments_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "valueType" && n.namespace_ ().empty ())
    {
      this->valueType_.set (valueType_traits::create (i, f, this));
      continue;
    }
  }

  if (!valueType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "valueType",
      "");
  }
}

FieldmlEvaluator_Type* FieldmlEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FieldmlEvaluator_Type (*this, f, c);
}

FieldmlEvaluator_Type& FieldmlEvaluator_Type::
operator= (const FieldmlEvaluator_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlObject_Type& > (*this) = x;
    this->Arguments_ = x.Arguments_;
    this->valueType_ = x.valueType_;
  }

  return *this;
}

FieldmlEvaluator_Type::
~FieldmlEvaluator_Type ()
{
}

// ArgumentEvaluator_Type
//

ArgumentEvaluator_Type::
ArgumentEvaluator_Type (const name_type& name,
                        const valueType_type& valueType)
: ::FieldmlEvaluator_Type (name,
                           valueType)
{
}

ArgumentEvaluator_Type::
ArgumentEvaluator_Type (const ArgumentEvaluator_Type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (x, f, c)
{
}

ArgumentEvaluator_Type::
ArgumentEvaluator_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (e, f, c)
{
}

ArgumentEvaluator_Type* ArgumentEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ArgumentEvaluator_Type (*this, f, c);
}

ArgumentEvaluator_Type::
~ArgumentEvaluator_Type ()
{
}

// ExternalEvaluator_Type
//

ExternalEvaluator_Type::
ExternalEvaluator_Type (const name_type& name,
                        const valueType_type& valueType)
: ::FieldmlEvaluator_Type (name,
                           valueType)
{
}

ExternalEvaluator_Type::
ExternalEvaluator_Type (const ExternalEvaluator_Type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (x, f, c)
{
}

ExternalEvaluator_Type::
ExternalEvaluator_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (e, f, c)
{
}

ExternalEvaluator_Type* ExternalEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ExternalEvaluator_Type (*this, f, c);
}

ExternalEvaluator_Type::
~ExternalEvaluator_Type ()
{
}

// ConstantEvaluator_Type
//

ConstantEvaluator_Type::
ConstantEvaluator_Type (const name_type& name,
                        const value_type& value,
                        const valueType_type& valueType)
: ::FieldmlObject_Type (name),
  value_ (value, this),
  valueType_ (valueType, this)
{
}

ConstantEvaluator_Type::
ConstantEvaluator_Type (const ConstantEvaluator_Type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::FieldmlObject_Type (x, f, c),
  value_ (x.value_, f, this),
  valueType_ (x.valueType_, f, this)
{
}

ConstantEvaluator_Type::
ConstantEvaluator_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::FieldmlObject_Type (e, f | ::xml_schema::flags::base, c),
  value_ (this),
  valueType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ConstantEvaluator_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlObject_Type::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "valueType" && n.namespace_ ().empty ())
    {
      this->valueType_.set (valueType_traits::create (i, f, this));
      continue;
    }
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "value",
      "");
  }

  if (!valueType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "valueType",
      "");
  }
}

ConstantEvaluator_Type* ConstantEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConstantEvaluator_Type (*this, f, c);
}

ConstantEvaluator_Type& ConstantEvaluator_Type::
operator= (const ConstantEvaluator_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlObject_Type& > (*this) = x;
    this->value_ = x.value_;
    this->valueType_ = x.valueType_;
  }

  return *this;
}

ConstantEvaluator_Type::
~ConstantEvaluator_Type ()
{
}

// ReferenceEvaluator_Type
//

ReferenceEvaluator_Type::
ReferenceEvaluator_Type (const name_type& name,
                         const evaluator_type& evaluator)
: ::FieldmlObject_Type (name),
  Arguments_ (this),
  Bindings_ (this),
  valueType_ (this),
  evaluator_ (evaluator, this)
{
}

ReferenceEvaluator_Type::
ReferenceEvaluator_Type (const ReferenceEvaluator_Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::FieldmlObject_Type (x, f, c),
  Arguments_ (x.Arguments_, f, this),
  Bindings_ (x.Bindings_, f, this),
  valueType_ (x.valueType_, f, this),
  evaluator_ (x.evaluator_, f, this)
{
}

ReferenceEvaluator_Type::
ReferenceEvaluator_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::FieldmlObject_Type (e, f | ::xml_schema::flags::base, c),
  Arguments_ (this),
  Bindings_ (this),
  valueType_ (this),
  evaluator_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ReferenceEvaluator_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlObject_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Arguments
    //
    if (n.name () == "Arguments" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Arguments_type > r (
        Arguments_traits::create (i, f, this));

      if (!this->Arguments_)
      {
        this->Arguments_.set (::std::move (r));
        continue;
      }
    }

    // Bindings
    //
    if (n.name () == "Bindings" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Bindings_type > r (
        Bindings_traits::create (i, f, this));

      if (!this->Bindings_)
      {
        this->Bindings_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "valueType" && n.namespace_ ().empty ())
    {
      this->valueType_.set (valueType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "evaluator" && n.namespace_ ().empty ())
    {
      this->evaluator_.set (evaluator_traits::create (i, f, this));
      continue;
    }
  }

  if (!evaluator_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "evaluator",
      "");
  }
}

ReferenceEvaluator_Type* ReferenceEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ReferenceEvaluator_Type (*this, f, c);
}

ReferenceEvaluator_Type& ReferenceEvaluator_Type::
operator= (const ReferenceEvaluator_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlObject_Type& > (*this) = x;
    this->Arguments_ = x.Arguments_;
    this->Bindings_ = x.Bindings_;
    this->valueType_ = x.valueType_;
    this->evaluator_ = x.evaluator_;
  }

  return *this;
}

ReferenceEvaluator_Type::
~ReferenceEvaluator_Type ()
{
}

// EvaluatorMapEntry_Type
//

EvaluatorMapEntry_Type::
EvaluatorMapEntry_Type (const value_type& value,
                        const evaluator_type& evaluator)
: ::xml_schema::type (),
  value_ (value, this),
  evaluator_ (evaluator, this)
{
}

EvaluatorMapEntry_Type::
EvaluatorMapEntry_Type (const EvaluatorMapEntry_Type& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this),
  evaluator_ (x.evaluator_, f, this)
{
}

EvaluatorMapEntry_Type::
EvaluatorMapEntry_Type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (this),
  evaluator_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void EvaluatorMapEntry_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.set (value_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "evaluator" && n.namespace_ ().empty ())
    {
      this->evaluator_.set (evaluator_traits::create (i, f, this));
      continue;
    }
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "value",
      "");
  }

  if (!evaluator_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "evaluator",
      "");
  }
}

EvaluatorMapEntry_Type* EvaluatorMapEntry_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EvaluatorMapEntry_Type (*this, f, c);
}

EvaluatorMapEntry_Type& EvaluatorMapEntry_Type::
operator= (const EvaluatorMapEntry_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->value_ = x.value_;
    this->evaluator_ = x.evaluator_;
  }

  return *this;
}

EvaluatorMapEntry_Type::
~EvaluatorMapEntry_Type ()
{
}

// EvaluatorMap_Type
//

EvaluatorMap_Type::
EvaluatorMap_Type ()
: ::xml_schema::type (),
  EvaluatorMapEntry_ (this),
  default__ (this)
{
}

EvaluatorMap_Type::
EvaluatorMap_Type (const EvaluatorMap_Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  EvaluatorMapEntry_ (x.EvaluatorMapEntry_, f, this),
  default__ (x.default__, f, this)
{
}

EvaluatorMap_Type::
EvaluatorMap_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  EvaluatorMapEntry_ (this),
  default__ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void EvaluatorMap_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // EvaluatorMapEntry
    //
    if (n.name () == "EvaluatorMapEntry" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< EvaluatorMapEntry_type > r (
        EvaluatorMapEntry_traits::create (i, f, this));

      this->EvaluatorMapEntry_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "default" && n.namespace_ ().empty ())
    {
      this->default__.set (default_traits::create (i, f, this));
      continue;
    }
  }
}

EvaluatorMap_Type* EvaluatorMap_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EvaluatorMap_Type (*this, f, c);
}

EvaluatorMap_Type& EvaluatorMap_Type::
operator= (const EvaluatorMap_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->EvaluatorMapEntry_ = x.EvaluatorMapEntry_;
    this->default__ = x.default__;
  }

  return *this;
}

EvaluatorMap_Type::
~EvaluatorMap_Type ()
{
}

// PiecewiseEvaluator_Type
//

PiecewiseEvaluator_Type::
PiecewiseEvaluator_Type (const name_type& name,
                         const valueType_type& valueType,
                         const EvaluatorMap_type& EvaluatorMap)
: ::FieldmlEvaluator_Type (name,
                           valueType),
  Bindings_ (this),
  IndexEvaluators_ (this),
  EvaluatorMap_ (EvaluatorMap, this)
{
}

PiecewiseEvaluator_Type::
PiecewiseEvaluator_Type (const name_type& name,
                         const valueType_type& valueType,
                         ::std::unique_ptr< EvaluatorMap_type > EvaluatorMap)
: ::FieldmlEvaluator_Type (name,
                           valueType),
  Bindings_ (this),
  IndexEvaluators_ (this),
  EvaluatorMap_ (std::move (EvaluatorMap), this)
{
}

PiecewiseEvaluator_Type::
PiecewiseEvaluator_Type (const PiecewiseEvaluator_Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (x, f, c),
  Bindings_ (x.Bindings_, f, this),
  IndexEvaluators_ (x.IndexEvaluators_, f, this),
  EvaluatorMap_ (x.EvaluatorMap_, f, this)
{
}

PiecewiseEvaluator_Type::
PiecewiseEvaluator_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (e, f | ::xml_schema::flags::base, c),
  Bindings_ (this),
  IndexEvaluators_ (this),
  EvaluatorMap_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void PiecewiseEvaluator_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlEvaluator_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Bindings
    //
    if (n.name () == "Bindings" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Bindings_type > r (
        Bindings_traits::create (i, f, this));

      if (!this->Bindings_)
      {
        this->Bindings_.set (::std::move (r));
        continue;
      }
    }

    // IndexEvaluators
    //
    if (n.name () == "IndexEvaluators" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< IndexEvaluators_type > r (
        IndexEvaluators_traits::create (i, f, this));

      if (!this->IndexEvaluators_)
      {
        this->IndexEvaluators_.set (::std::move (r));
        continue;
      }
    }

    // EvaluatorMap
    //
    if (n.name () == "EvaluatorMap" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< EvaluatorMap_type > r (
        EvaluatorMap_traits::create (i, f, this));

      if (!EvaluatorMap_.present ())
      {
        this->EvaluatorMap_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!EvaluatorMap_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EvaluatorMap",
      "");
  }
}

PiecewiseEvaluator_Type* PiecewiseEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PiecewiseEvaluator_Type (*this, f, c);
}

PiecewiseEvaluator_Type& PiecewiseEvaluator_Type::
operator= (const PiecewiseEvaluator_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlEvaluator_Type& > (*this) = x;
    this->Bindings_ = x.Bindings_;
    this->IndexEvaluators_ = x.IndexEvaluators_;
    this->EvaluatorMap_ = x.EvaluatorMap_;
  }

  return *this;
}

PiecewiseEvaluator_Type::
~PiecewiseEvaluator_Type ()
{
}

// DenseArrayData_Type
//

DenseArrayData_Type::
DenseArrayData_Type (const data_type& data)
: ::xml_schema::type (),
  DenseIndexes_ (this),
  data_ (data, this)
{
}

DenseArrayData_Type::
DenseArrayData_Type (const DenseArrayData_Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DenseIndexes_ (x.DenseIndexes_, f, this),
  data_ (x.data_, f, this)
{
}

DenseArrayData_Type::
DenseArrayData_Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DenseIndexes_ (this),
  data_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void DenseArrayData_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DenseIndexes
    //
    if (n.name () == "DenseIndexes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DenseIndexes_type > r (
        DenseIndexes_traits::create (i, f, this));

      if (!this->DenseIndexes_)
      {
        this->DenseIndexes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "data" && n.namespace_ ().empty ())
    {
      this->data_.set (data_traits::create (i, f, this));
      continue;
    }
  }

  if (!data_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "data",
      "");
  }
}

DenseArrayData_Type* DenseArrayData_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DenseArrayData_Type (*this, f, c);
}

DenseArrayData_Type& DenseArrayData_Type::
operator= (const DenseArrayData_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DenseIndexes_ = x.DenseIndexes_;
    this->data_ = x.data_;
  }

  return *this;
}

DenseArrayData_Type::
~DenseArrayData_Type ()
{
}

// DOKArrayData_Type
//

DOKArrayData_Type::
DOKArrayData_Type (const SparseIndexes_type& SparseIndexes,
                   const keyData_type& keyData,
                   const valueData_type& valueData)
: ::xml_schema::type (),
  DenseIndexes_ (this),
  SparseIndexes_ (SparseIndexes, this),
  keyData_ (keyData, this),
  valueData_ (valueData, this)
{
}

DOKArrayData_Type::
DOKArrayData_Type (::std::unique_ptr< SparseIndexes_type > SparseIndexes,
                   const keyData_type& keyData,
                   const valueData_type& valueData)
: ::xml_schema::type (),
  DenseIndexes_ (this),
  SparseIndexes_ (std::move (SparseIndexes), this),
  keyData_ (keyData, this),
  valueData_ (valueData, this)
{
}

DOKArrayData_Type::
DOKArrayData_Type (const DOKArrayData_Type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DenseIndexes_ (x.DenseIndexes_, f, this),
  SparseIndexes_ (x.SparseIndexes_, f, this),
  keyData_ (x.keyData_, f, this),
  valueData_ (x.valueData_, f, this)
{
}

DOKArrayData_Type::
DOKArrayData_Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DenseIndexes_ (this),
  SparseIndexes_ (this),
  keyData_ (this),
  valueData_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void DOKArrayData_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DenseIndexes
    //
    if (n.name () == "DenseIndexes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DenseIndexes_type > r (
        DenseIndexes_traits::create (i, f, this));

      if (!this->DenseIndexes_)
      {
        this->DenseIndexes_.set (::std::move (r));
        continue;
      }
    }

    // SparseIndexes
    //
    if (n.name () == "SparseIndexes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< SparseIndexes_type > r (
        SparseIndexes_traits::create (i, f, this));

      if (!SparseIndexes_.present ())
      {
        this->SparseIndexes_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!SparseIndexes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SparseIndexes",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyData" && n.namespace_ ().empty ())
    {
      this->keyData_.set (keyData_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "valueData" && n.namespace_ ().empty ())
    {
      this->valueData_.set (valueData_traits::create (i, f, this));
      continue;
    }
  }

  if (!keyData_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "keyData",
      "");
  }

  if (!valueData_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "valueData",
      "");
  }
}

DOKArrayData_Type* DOKArrayData_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DOKArrayData_Type (*this, f, c);
}

DOKArrayData_Type& DOKArrayData_Type::
operator= (const DOKArrayData_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DenseIndexes_ = x.DenseIndexes_;
    this->SparseIndexes_ = x.SparseIndexes_;
    this->keyData_ = x.keyData_;
    this->valueData_ = x.valueData_;
  }

  return *this;
}

DOKArrayData_Type::
~DOKArrayData_Type ()
{
}

// ParameterEvaluator_Type
//

ParameterEvaluator_Type::
ParameterEvaluator_Type (const name_type& name,
                         const valueType_type& valueType)
: ::FieldmlEvaluator_Type (name,
                           valueType),
  DenseArrayData_ (this),
  DOKArrayData_ (this)
{
}

ParameterEvaluator_Type::
ParameterEvaluator_Type (const ParameterEvaluator_Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (x, f, c),
  DenseArrayData_ (x.DenseArrayData_, f, this),
  DOKArrayData_ (x.DOKArrayData_, f, this)
{
}

ParameterEvaluator_Type::
ParameterEvaluator_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (e, f | ::xml_schema::flags::base, c),
  DenseArrayData_ (this),
  DOKArrayData_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ParameterEvaluator_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlEvaluator_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DenseArrayData
    //
    if (n.name () == "DenseArrayData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DenseArrayData_type > r (
        DenseArrayData_traits::create (i, f, this));

      if (!this->DenseArrayData_)
      {
        this->DenseArrayData_.set (::std::move (r));
        continue;
      }
    }

    // DOKArrayData
    //
    if (n.name () == "DOKArrayData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DOKArrayData_type > r (
        DOKArrayData_traits::create (i, f, this));

      if (!this->DOKArrayData_)
      {
        this->DOKArrayData_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

ParameterEvaluator_Type* ParameterEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParameterEvaluator_Type (*this, f, c);
}

ParameterEvaluator_Type& ParameterEvaluator_Type::
operator= (const ParameterEvaluator_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlEvaluator_Type& > (*this) = x;
    this->DenseArrayData_ = x.DenseArrayData_;
    this->DOKArrayData_ = x.DOKArrayData_;
  }

  return *this;
}

ParameterEvaluator_Type::
~ParameterEvaluator_Type ()
{
}

// AggregateEvaluator_Type
//

AggregateEvaluator_Type::
AggregateEvaluator_Type (const name_type& name,
                         const valueType_type& valueType,
                         const ComponentEvaluators_type& ComponentEvaluators)
: ::FieldmlEvaluator_Type (name,
                           valueType),
  Bindings_ (this),
  ComponentEvaluators_ (ComponentEvaluators, this)
{
}

AggregateEvaluator_Type::
AggregateEvaluator_Type (const name_type& name,
                         const valueType_type& valueType,
                         ::std::unique_ptr< ComponentEvaluators_type > ComponentEvaluators)
: ::FieldmlEvaluator_Type (name,
                           valueType),
  Bindings_ (this),
  ComponentEvaluators_ (std::move (ComponentEvaluators), this)
{
}

AggregateEvaluator_Type::
AggregateEvaluator_Type (const AggregateEvaluator_Type& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (x, f, c),
  Bindings_ (x.Bindings_, f, this),
  ComponentEvaluators_ (x.ComponentEvaluators_, f, this)
{
}

AggregateEvaluator_Type::
AggregateEvaluator_Type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::FieldmlEvaluator_Type (e, f | ::xml_schema::flags::base, c),
  Bindings_ (this),
  ComponentEvaluators_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void AggregateEvaluator_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlEvaluator_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Bindings
    //
    if (n.name () == "Bindings" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Bindings_type > r (
        Bindings_traits::create (i, f, this));

      if (!this->Bindings_)
      {
        this->Bindings_.set (::std::move (r));
        continue;
      }
    }

    // ComponentEvaluators
    //
    if (n.name () == "ComponentEvaluators" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ComponentEvaluators_type > r (
        ComponentEvaluators_traits::create (i, f, this));

      if (!ComponentEvaluators_.present ())
      {
        this->ComponentEvaluators_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!ComponentEvaluators_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ComponentEvaluators",
      "");
  }
}

AggregateEvaluator_Type* AggregateEvaluator_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AggregateEvaluator_Type (*this, f, c);
}

AggregateEvaluator_Type& AggregateEvaluator_Type::
operator= (const AggregateEvaluator_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlEvaluator_Type& > (*this) = x;
    this->Bindings_ = x.Bindings_;
    this->ComponentEvaluators_ = x.ComponentEvaluators_;
  }

  return *this;
}

AggregateEvaluator_Type::
~AggregateEvaluator_Type ()
{
}

// Region_Type
//

Region_Type::
Region_Type (const name_type& name)
: ::FieldmlRdfTargetType (),
  Import_ (this),
  DataResource_ (this),
  BooleanType_ (this),
  EnsembleType_ (this),
  ContinuousType_ (this),
  MeshType_ (this),
  ArgumentEvaluator_ (this),
  ExternalEvaluator_ (this),
  ReferenceEvaluator_ (this),
  ConstantEvaluator_ (this),
  PiecewiseEvaluator_ (this),
  ParameterEvaluator_ (this),
  AggregateEvaluator_ (this),
  name_ (name, this)
{
}

Region_Type::
Region_Type (const Region_Type& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::FieldmlRdfTargetType (x, f, c),
  Import_ (x.Import_, f, this),
  DataResource_ (x.DataResource_, f, this),
  BooleanType_ (x.BooleanType_, f, this),
  EnsembleType_ (x.EnsembleType_, f, this),
  ContinuousType_ (x.ContinuousType_, f, this),
  MeshType_ (x.MeshType_, f, this),
  ArgumentEvaluator_ (x.ArgumentEvaluator_, f, this),
  ExternalEvaluator_ (x.ExternalEvaluator_, f, this),
  ReferenceEvaluator_ (x.ReferenceEvaluator_, f, this),
  ConstantEvaluator_ (x.ConstantEvaluator_, f, this),
  PiecewiseEvaluator_ (x.PiecewiseEvaluator_, f, this),
  ParameterEvaluator_ (x.ParameterEvaluator_, f, this),
  AggregateEvaluator_ (x.AggregateEvaluator_, f, this),
  name_ (x.name_, f, this)
{
}

Region_Type::
Region_Type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::FieldmlRdfTargetType (e, f | ::xml_schema::flags::base, c),
  Import_ (this),
  DataResource_ (this),
  BooleanType_ (this),
  EnsembleType_ (this),
  ContinuousType_ (this),
  MeshType_ (this),
  ArgumentEvaluator_ (this),
  ExternalEvaluator_ (this),
  ReferenceEvaluator_ (this),
  ConstantEvaluator_ (this),
  PiecewiseEvaluator_ (this),
  ParameterEvaluator_ (this),
  AggregateEvaluator_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Region_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlRdfTargetType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Import
    //
    if (n.name () == "Import" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Import_type > r (
        Import_traits::create (i, f, this));

      this->Import_.push_back (::std::move (r));
      continue;
    }

    // DataResource
    //
    if (n.name () == "DataResource" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DataResource_type > r (
        DataResource_traits::create (i, f, this));

      this->DataResource_.push_back (::std::move (r));
      continue;
    }

    // BooleanType
    //
    if (n.name () == "BooleanType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< BooleanType_type > r (
        BooleanType_traits::create (i, f, this));

      this->BooleanType_.push_back (::std::move (r));
      continue;
    }

    // EnsembleType
    //
    if (n.name () == "EnsembleType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< EnsembleType_type > r (
        EnsembleType_traits::create (i, f, this));

      this->EnsembleType_.push_back (::std::move (r));
      continue;
    }

    // ContinuousType
    //
    if (n.name () == "ContinuousType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ContinuousType_type > r (
        ContinuousType_traits::create (i, f, this));

      this->ContinuousType_.push_back (::std::move (r));
      continue;
    }

    // MeshType
    //
    if (n.name () == "MeshType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< MeshType_type > r (
        MeshType_traits::create (i, f, this));

      this->MeshType_.push_back (::std::move (r));
      continue;
    }

    // ArgumentEvaluator
    //
    if (n.name () == "ArgumentEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ArgumentEvaluator_type > r (
        ArgumentEvaluator_traits::create (i, f, this));

      this->ArgumentEvaluator_.push_back (::std::move (r));
      continue;
    }

    // ExternalEvaluator
    //
    if (n.name () == "ExternalEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ExternalEvaluator_type > r (
        ExternalEvaluator_traits::create (i, f, this));

      this->ExternalEvaluator_.push_back (::std::move (r));
      continue;
    }

    // ReferenceEvaluator
    //
    if (n.name () == "ReferenceEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ReferenceEvaluator_type > r (
        ReferenceEvaluator_traits::create (i, f, this));

      this->ReferenceEvaluator_.push_back (::std::move (r));
      continue;
    }

    // ConstantEvaluator
    //
    if (n.name () == "ConstantEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ConstantEvaluator_type > r (
        ConstantEvaluator_traits::create (i, f, this));

      this->ConstantEvaluator_.push_back (::std::move (r));
      continue;
    }

    // PiecewiseEvaluator
    //
    if (n.name () == "PiecewiseEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< PiecewiseEvaluator_type > r (
        PiecewiseEvaluator_traits::create (i, f, this));

      this->PiecewiseEvaluator_.push_back (::std::move (r));
      continue;
    }

    // ParameterEvaluator
    //
    if (n.name () == "ParameterEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ParameterEvaluator_type > r (
        ParameterEvaluator_traits::create (i, f, this));

      this->ParameterEvaluator_.push_back (::std::move (r));
      continue;
    }

    // AggregateEvaluator
    //
    if (n.name () == "AggregateEvaluator" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< AggregateEvaluator_type > r (
        AggregateEvaluator_traits::create (i, f, this));

      this->AggregateEvaluator_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

Region_Type* Region_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Region_Type (*this, f, c);
}

Region_Type& Region_Type::
operator= (const Region_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlRdfTargetType& > (*this) = x;
    this->Import_ = x.Import_;
    this->DataResource_ = x.DataResource_;
    this->BooleanType_ = x.BooleanType_;
    this->EnsembleType_ = x.EnsembleType_;
    this->ContinuousType_ = x.ContinuousType_;
    this->MeshType_ = x.MeshType_;
    this->ArgumentEvaluator_ = x.ArgumentEvaluator_;
    this->ExternalEvaluator_ = x.ExternalEvaluator_;
    this->ReferenceEvaluator_ = x.ReferenceEvaluator_;
    this->ConstantEvaluator_ = x.ConstantEvaluator_;
    this->PiecewiseEvaluator_ = x.PiecewiseEvaluator_;
    this->ParameterEvaluator_ = x.ParameterEvaluator_;
    this->AggregateEvaluator_ = x.AggregateEvaluator_;
    this->name_ = x.name_;
  }

  return *this;
}

Region_Type::
~Region_Type ()
{
}

// Fieldml_Type
//

Fieldml_Type::
Fieldml_Type (const Region_type& Region)
: ::FieldmlRdfTargetType (),
  Region_ (Region, this),
  version_ (this)
{
}

Fieldml_Type::
Fieldml_Type (::std::unique_ptr< Region_type > Region)
: ::FieldmlRdfTargetType (),
  Region_ (std::move (Region), this),
  version_ (this)
{
}

Fieldml_Type::
Fieldml_Type (const Fieldml_Type& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::FieldmlRdfTargetType (x, f, c),
  Region_ (x.Region_, f, this),
  version_ (x.version_, f, this)
{
}

Fieldml_Type::
Fieldml_Type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::FieldmlRdfTargetType (e, f | ::xml_schema::flags::base, c),
  Region_ (this),
  version_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Fieldml_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::FieldmlRdfTargetType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Region
    //
    if (n.name () == "Region" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Region_type > r (
        Region_traits::create (i, f, this));

      if (!Region_.present ())
      {
        this->Region_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Region_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Region",
      "");
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version_.set (version_traits::create (i, f, this));
      continue;
    }
  }
}

Fieldml_Type* Fieldml_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Fieldml_Type (*this, f, c);
}

Fieldml_Type& Fieldml_Type::
operator= (const Fieldml_Type& x)
{
  if (this != &x)
  {
    static_cast< ::FieldmlRdfTargetType& > (*this) = x;
    this->Region_ = x.Region_;
    this->version_ = x.version_;
  }

  return *this;
}

Fieldml_Type::
~Fieldml_Type ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Fieldml_Type > (
    ::Fieldml (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Fieldml_Type > (
    ::Fieldml (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Fieldml_Type > (
    ::Fieldml (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Fieldml (isrc, f, p);
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Fieldml (isrc, h, f, p);
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Fieldml (isrc, h, f, p);
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Fieldml (isrc, f, p);
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Fieldml (isrc, h, f, p);
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Fieldml (isrc, h, f, p);
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Fieldml_Type > (
    ::Fieldml (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Fieldml_Type > (
    ::Fieldml (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Fieldml_Type > (
    ::Fieldml (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Fieldml_Type > (
      ::Fieldml (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Fieldml" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Fieldml_Type > r (
      ::xsd::cxx::tree::traits< ::Fieldml_Type, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Fieldml",
    "");
}

::std::unique_ptr< ::Fieldml_Type >
Fieldml (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Fieldml" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Fieldml_Type > r (
      ::xsd::cxx::tree::traits< ::Fieldml_Type, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Fieldml",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const FieldmlRdfTargetType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  if (i.id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << *i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FieldmlObject_Type& i)
{
  e << static_cast< const ::FieldmlRdfTargetType& > (i);

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ArrayDataSize_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ArrayDataSize_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ArrayDataSize_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ArrayDataOffset_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ArrayDataOffset_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ArrayDataOffset_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RawArraySize_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RawArraySize_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RawArraySize_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ArrayDataSource_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ArrayDataSize
  //
  for (ArrayDataSource_Type::ArrayDataSize_const_iterator
       b (i.ArrayDataSize ().begin ()), n (i.ArrayDataSize ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ArrayDataSize",
        e));

    s << *b;
  }

  // ArrayDataOffset
  //
  for (ArrayDataSource_Type::ArrayDataOffset_const_iterator
       b (i.ArrayDataOffset ().begin ()), n (i.ArrayDataOffset ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ArrayDataOffset",
        e));

    s << *b;
  }

  // RawArraySize
  //
  for (ArrayDataSource_Type::RawArraySize_const_iterator
       b (i.RawArraySize ().begin ()), n (i.RawArraySize ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RawArraySize",
        e));

    s << *b;
  }

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }

  // location
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "location",
        e));

    a << i.location ();
  }

  // rank
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rank",
        e));

    a << i.rank ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DataResourceHref_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // href
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "href",
        "http://www.w3.org/1999/xlink",
        e));

    a << i.href ();
  }

  // format
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "format",
        e));

    a << i.format ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DataResourceString_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const DataResourceString_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const DataResourceString_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const DataResourceDescription_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // DataResourceHref
  //
  if (i.DataResourceHref ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DataResourceHref",
        e));

    s << *i.DataResourceHref ();
  }

  // DataResourceString
  //
  if (i.DataResourceString ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DataResourceString",
        e));

    s << *i.DataResourceString ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DataResource_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // DataResourceDescription
  //
  for (DataResource_Type::DataResourceDescription_const_iterator
       b (i.DataResourceDescription ().begin ()), n (i.DataResourceDescription ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DataResourceDescription",
        e));

    s << *b;
  }

  // ArrayDataSource
  //
  for (DataResource_Type::ArrayDataSource_const_iterator
       b (i.ArrayDataSource ().begin ()), n (i.ArrayDataSource ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ArrayDataSource",
        e));

    s << *b;
  }

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ImportTypeEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // localName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "localName",
        e));

    a << i.localName ();
  }

  // remoteName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "remoteName",
        e));

    a << i.remoteName ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ImportEvaluatorEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // localName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "localName",
        e));

    a << i.localName ();
  }

  // remoteName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "remoteName",
        e));

    a << i.remoteName ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Import_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ImportType
  //
  for (Import_Type::ImportType_const_iterator
       b (i.ImportType ().begin ()), n (i.ImportType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ImportType",
        e));

    s << *b;
  }

  // ImportEvaluator
  //
  for (Import_Type::ImportEvaluator_const_iterator
       b (i.ImportEvaluator ().begin ()), n (i.ImportEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ImportEvaluator",
        e));

    s << *b;
  }

  // href
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "href",
        "http://www.w3.org/1999/xlink",
        e));

    a << i.href ();
  }

  // region
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "region",
        e));

    a << i.region ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const NumberedIndexEvaluator_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // evaluator
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "evaluator",
        e));

    a << i.evaluator ();
  }

  // indexNumber
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "indexNumber",
        e));

    a << i.indexNumber ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const NumberedIndexEvaluatorList_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // IndexEvaluator
  //
  for (NumberedIndexEvaluatorList_Type::IndexEvaluator_const_iterator
       b (i.IndexEvaluator ().begin ()), n (i.IndexEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IndexEvaluator",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const BindMapEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // argument
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "argument",
        e));

    a << i.argument ();
  }

  // source
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "source",
        e));

    a << i.source ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BindMapIndexEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // argument
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "argument",
        e));

    a << i.argument ();
  }

  // indexNumber
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "indexNumber",
        e));

    a << i.indexNumber ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BindMapWithIndexes_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // BindIndex
  //
  for (BindMapWithIndexes_Type::BindIndex_const_iterator
       b (i.BindIndex ().begin ()), n (i.BindIndex ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BindIndex",
        e));

    s << *b;
  }

  // Bind
  //
  for (BindMapWithIndexes_Type::Bind_const_iterator
       b (i.Bind ().begin ()), n (i.Bind ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Bind",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const BindMap_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Bind
  //
  for (BindMap_Type::Bind_const_iterator
       b (i.Bind ().begin ()), n (i.Bind ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Bind",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ComponentEvaluatorsEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // component
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "component",
        e));

    a << i.component ();
  }

  // evaluator
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "evaluator",
        e));

    a << i.evaluator ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ComponentEvaluators_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ComponentEvaluator
  //
  for (ComponentEvaluators_Type::ComponentEvaluator_const_iterator
       b (i.ComponentEvaluator ().begin ()), n (i.ComponentEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ComponentEvaluator",
        e));

    s << *b;
  }

  // default
  //
  if (i.default_ ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "default",
        e));

    a << *i.default_ ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ShapeMap_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // evaluator
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "evaluator",
        e));

    a << i.evaluator ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ArgumentListEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ArgumentList_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Argument
  //
  for (ArgumentList_Type::Argument_const_iterator
       b (i.Argument ().begin ()), n (i.Argument ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Argument",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const EvaluatorListEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // evaluator
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "evaluator",
        e));

    a << i.evaluator ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const IndexEvaluatorList_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // IndexEvaluator
  //
  for (IndexEvaluatorList_Type::IndexEvaluator_const_iterator
       b (i.IndexEvaluator ().begin ()), n (i.IndexEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IndexEvaluator",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const OrderedEvaluatorListEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // evaluator
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "evaluator",
        e));

    a << i.evaluator ();
  }

  // order
  //
  if (i.order ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "order",
        e));

    a << *i.order ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const OrderedIndexEvaluatorList_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // IndexEvaluator
  //
  for (OrderedIndexEvaluatorList_Type::IndexEvaluator_const_iterator
       b (i.IndexEvaluator ().begin ()), n (i.IndexEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IndexEvaluator",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const MemberRange_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // min
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "min",
        e));

    a << i.min ();
  }

  // max
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max",
        e));

    a << i.max ();
  }

  // stride
  //
  if (i.stride ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "stride",
        e));

    a << *i.stride ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MemberData_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // count
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "count",
        e));

    a << i.count ();
  }

  // data
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "data",
        e));

    a << i.data ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EnsembleMembers_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // MemberListData
  //
  if (i.MemberListData ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MemberListData",
        e));

    s << *i.MemberListData ();
  }

  // MemberRangeData
  //
  if (i.MemberRangeData ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MemberRangeData",
        e));

    s << *i.MemberRangeData ();
  }

  // MemberStrideRangeData
  //
  if (i.MemberStrideRangeData ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MemberStrideRangeData",
        e));

    s << *i.MemberStrideRangeData ();
  }

  // MemberRange
  //
  if (i.MemberRange ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MemberRange",
        e));

    s << *i.MemberRange ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const BooleanType_Type& i)
{
  e << static_cast< const ::FieldmlObject_Type& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const EnsembleType_Type& i)
{
  e << static_cast< const ::FieldmlObject_Type& > (i);

  // Members
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Members",
        e));

    s << i.Members ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ContinuousComponent_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }

  // count
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "count",
        e));

    a << i.count ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ContinuousType_Type& i)
{
  e << static_cast< const ::FieldmlObject_Type& > (i);

  // Components
  //
  if (i.Components ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Components",
        e));

    s << *i.Components ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MeshType_Type& i)
{
  e << static_cast< const ::FieldmlObject_Type& > (i);

  // Elements
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Elements",
        e));

    s << i.Elements ();
  }

  // Chart
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Chart",
        e));

    s << i.Chart ();
  }

  // Shapes
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Shapes",
        e));

    s << i.Shapes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FieldmlEvaluator_Type& i)
{
  e << static_cast< const ::FieldmlObject_Type& > (i);

  // Arguments
  //
  if (i.Arguments ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Arguments",
        e));

    s << *i.Arguments ();
  }

  // valueType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "valueType",
        e));

    a << i.valueType ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ArgumentEvaluator_Type& i)
{
  e << static_cast< const ::FieldmlEvaluator_Type& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ExternalEvaluator_Type& i)
{
  e << static_cast< const ::FieldmlEvaluator_Type& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ConstantEvaluator_Type& i)
{
  e << static_cast< const ::FieldmlObject_Type& > (i);

  // value
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "value",
        e));

    a << i.value ();
  }

  // valueType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "valueType",
        e));

    a << i.valueType ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ReferenceEvaluator_Type& i)
{
  e << static_cast< const ::FieldmlObject_Type& > (i);

  // Arguments
  //
  if (i.Arguments ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Arguments",
        e));

    s << *i.Arguments ();
  }

  // Bindings
  //
  if (i.Bindings ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Bindings",
        e));

    s << *i.Bindings ();
  }

  // valueType
  //
  if (i.valueType ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "valueType",
        e));

    a << *i.valueType ();
  }

  // evaluator
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "evaluator",
        e));

    a << i.evaluator ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EvaluatorMapEntry_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // value
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "value",
        e));

    a << i.value ();
  }

  // evaluator
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "evaluator",
        e));

    a << i.evaluator ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const EvaluatorMap_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // EvaluatorMapEntry
  //
  for (EvaluatorMap_Type::EvaluatorMapEntry_const_iterator
       b (i.EvaluatorMapEntry ().begin ()), n (i.EvaluatorMapEntry ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EvaluatorMapEntry",
        e));

    s << *b;
  }

  // default
  //
  if (i.default_ ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "default",
        e));

    a << *i.default_ ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PiecewiseEvaluator_Type& i)
{
  e << static_cast< const ::FieldmlEvaluator_Type& > (i);

  // Bindings
  //
  if (i.Bindings ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Bindings",
        e));

    s << *i.Bindings ();
  }

  // IndexEvaluators
  //
  if (i.IndexEvaluators ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IndexEvaluators",
        e));

    s << *i.IndexEvaluators ();
  }

  // EvaluatorMap
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EvaluatorMap",
        e));

    s << i.EvaluatorMap ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DenseArrayData_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // DenseIndexes
  //
  if (i.DenseIndexes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DenseIndexes",
        e));

    s << *i.DenseIndexes ();
  }

  // data
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "data",
        e));

    a << i.data ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DOKArrayData_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // DenseIndexes
  //
  if (i.DenseIndexes ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DenseIndexes",
        e));

    s << *i.DenseIndexes ();
  }

  // SparseIndexes
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SparseIndexes",
        e));

    s << i.SparseIndexes ();
  }

  // keyData
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "keyData",
        e));

    a << i.keyData ();
  }

  // valueData
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "valueData",
        e));

    a << i.valueData ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ParameterEvaluator_Type& i)
{
  e << static_cast< const ::FieldmlEvaluator_Type& > (i);

  // DenseArrayData
  //
  if (i.DenseArrayData ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DenseArrayData",
        e));

    s << *i.DenseArrayData ();
  }

  // DOKArrayData
  //
  if (i.DOKArrayData ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DOKArrayData",
        e));

    s << *i.DOKArrayData ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AggregateEvaluator_Type& i)
{
  e << static_cast< const ::FieldmlEvaluator_Type& > (i);

  // Bindings
  //
  if (i.Bindings ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Bindings",
        e));

    s << *i.Bindings ();
  }

  // ComponentEvaluators
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ComponentEvaluators",
        e));

    s << i.ComponentEvaluators ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Region_Type& i)
{
  e << static_cast< const ::FieldmlRdfTargetType& > (i);

  // Import
  //
  for (Region_Type::Import_const_iterator
       b (i.Import ().begin ()), n (i.Import ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Import",
        e));

    s << *b;
  }

  // DataResource
  //
  for (Region_Type::DataResource_const_iterator
       b (i.DataResource ().begin ()), n (i.DataResource ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DataResource",
        e));

    s << *b;
  }

  // BooleanType
  //
  for (Region_Type::BooleanType_const_iterator
       b (i.BooleanType ().begin ()), n (i.BooleanType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BooleanType",
        e));

    s << *b;
  }

  // EnsembleType
  //
  for (Region_Type::EnsembleType_const_iterator
       b (i.EnsembleType ().begin ()), n (i.EnsembleType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EnsembleType",
        e));

    s << *b;
  }

  // ContinuousType
  //
  for (Region_Type::ContinuousType_const_iterator
       b (i.ContinuousType ().begin ()), n (i.ContinuousType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ContinuousType",
        e));

    s << *b;
  }

  // MeshType
  //
  for (Region_Type::MeshType_const_iterator
       b (i.MeshType ().begin ()), n (i.MeshType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MeshType",
        e));

    s << *b;
  }

  // ArgumentEvaluator
  //
  for (Region_Type::ArgumentEvaluator_const_iterator
       b (i.ArgumentEvaluator ().begin ()), n (i.ArgumentEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ArgumentEvaluator",
        e));

    s << *b;
  }

  // ExternalEvaluator
  //
  for (Region_Type::ExternalEvaluator_const_iterator
       b (i.ExternalEvaluator ().begin ()), n (i.ExternalEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ExternalEvaluator",
        e));

    s << *b;
  }

  // ReferenceEvaluator
  //
  for (Region_Type::ReferenceEvaluator_const_iterator
       b (i.ReferenceEvaluator ().begin ()), n (i.ReferenceEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReferenceEvaluator",
        e));

    s << *b;
  }

  // ConstantEvaluator
  //
  for (Region_Type::ConstantEvaluator_const_iterator
       b (i.ConstantEvaluator ().begin ()), n (i.ConstantEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ConstantEvaluator",
        e));

    s << *b;
  }

  // PiecewiseEvaluator
  //
  for (Region_Type::PiecewiseEvaluator_const_iterator
       b (i.PiecewiseEvaluator ().begin ()), n (i.PiecewiseEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PiecewiseEvaluator",
        e));

    s << *b;
  }

  // ParameterEvaluator
  //
  for (Region_Type::ParameterEvaluator_const_iterator
       b (i.ParameterEvaluator ().begin ()), n (i.ParameterEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ParameterEvaluator",
        e));

    s << *b;
  }

  // AggregateEvaluator
  //
  for (Region_Type::AggregateEvaluator_const_iterator
       b (i.AggregateEvaluator ().begin ()), n (i.AggregateEvaluator ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AggregateEvaluator",
        e));

    s << *b;
  }

  // name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "name",
        e));

    a << i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Fieldml_Type& i)
{
  e << static_cast< const ::FieldmlRdfTargetType& > (i);

  // Region
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Region",
        e));

    s << i.Region ();
  }

  // version
  //
  if (i.version ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "version",
        e));

    a << *i.version ();
  }
}

void
Fieldml (::std::ostream& o,
         const ::Fieldml_Type& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Fieldml (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Fieldml (::std::ostream& o,
         const ::Fieldml_Type& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Fieldml (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Fieldml (::std::ostream& o,
         const ::Fieldml_Type& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Fieldml (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Fieldml (::xercesc::XMLFormatTarget& t,
         const ::Fieldml_Type& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Fieldml (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Fieldml (::xercesc::XMLFormatTarget& t,
         const ::Fieldml_Type& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Fieldml (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Fieldml (::xercesc::XMLFormatTarget& t,
         const ::Fieldml_Type& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Fieldml (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Fieldml (::xercesc::DOMDocument& d,
         const ::Fieldml_Type& s,
         ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Fieldml" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Fieldml",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
Fieldml (const ::Fieldml_Type& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "Fieldml",
      "",
      m, f));

  ::Fieldml (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

